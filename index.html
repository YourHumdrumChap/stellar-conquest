<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Galactic Conquest — RTS Prototype</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1626;--accent:#4ea3ff;--accent2:#ff6b6b;--muted:#98a0b3}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system,Segoe UI, Roboto, 'Helvetica Neue', Arial;color:#dbe6ff;background:linear-gradient(180deg,#071020 0%, #081223 60%);}
    #container{display:flex;height:100vh;gap:12px;padding:14px;box-sizing:border-box}
    #leftPane{width:260px;flex-shrink:0}
    #menu, #settings{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    h1{font-size:18px;margin:0 0 12px 0}
    label{display:block;margin-top:8px;font-size:13px;color:var(--muted)}
    input[type=range]{width:100%}
    select,button{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button.primary{background:linear-gradient(90deg,var(--accent),#2ec4ff);color:#021022;border:none;font-weight:600}
    #gameArea{flex:1;position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#061122,#071426)}
    #topBar{position:absolute;left:12px;top:12px;z-index:20;background:rgba(5,8,15,0.6);padding:8px;border-radius:8px;display:flex;gap:8px;align-items:center}
    #hud{position:absolute;right:12px;top:12px;z-index:20;background:rgba(5,8,15,0.6);padding:8px;border-radius:8px;min-width:220px}
    #canvasWrap{width:100%;height:100%;display:flex}
    canvas{flex:1;display:block;cursor:crosshair}
    .panel{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    .systemInfo{font-size:13px;margin-top:8px}
    .btnRow{display:flex;gap:8px;margin-top:8px}
    .controlBtn{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    #footer{position:absolute;left:12px;bottom:12px;z-index:20;color:var(--muted);font-size:12px}
    .legend{display:flex;gap:8px;align-items:center}
    .legend .dot{width:12px;height:12px;border-radius:3px}
    #minimap{width:200px;height:120px;border-radius:8px;background:rgba(0,0,0,0.2);margin-top:8px}
    /* UI adapt */
    @media (max-width:900px){#leftPane{display:none}}
  </style>
</head>
<body>
  <div id="container">
    <div id="leftPane">
      <div id="menu">
        <h1>Galactic Conquest</h1>
        <div class="small">A lightweight real-time strategy prototype — HTML + JS. Choose difficulty and galaxy size, then Launch.</div>
        <label for="difficulty">AI Difficulty</label>
        <select id="difficulty">
          <option value="0.8">Easy</option>
          <option value="1.0" selected>Normal</option>
          <option value="1.3">Hard</option>
        </select>
        <label for="systemsRange">Number of Star Systems <span id="sysCount">60</span></label>
        <input id="systemsRange" type="range" min="5" max="300" value="60">
        <label for="seed">Galaxy Seed (leave blank for random)</label>
        <input id="seed" placeholder="optional seed text" />
        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="launchBtn" class="primary">Launch</button>
          <button id="loadExample">Example</button>
        </div>
        <div class="panel">
          <div class="small">Controls</div>
          <ul class="small">
            <li>Click a system to select it.</li>
            <li>Build fleets in controlled systems.</li>
            <li>Select a fleet, click "Send Fleet", then click destination (pathfinding finds route).</li>
            <li>Zoom with mouse wheel. Pan with right-drag.</li>
          </ul>
        </div>
      </div>

      <div id="settings" style="margin-top:12px">
        <div class="small">Tips</div>
        <div class="small systemInfo" id="tipsText">Economy fuels your fleet production. Capture systems to grow income. AI difficulty affects build speed and aggressiveness.</div>
      </div>
    </div>

    <div id="gameArea">
      <div id="topBar" style="display:none">
        <button id="toMenu">Main Menu</button>
        <div class="small" id="statusText">Status:</div>
      </div>

      <div id="hud" style="display:none">
        <div class="small">Credits: <span id="credits">0</span></div>
        <div class="small">Income/sec: <span id="income">0</span></div>
        <div class="small">Time: <span id="timeLabel">0s</span></div>
        <div class="panel">
          <div class="small">Selected</div>
          <div id="selectedName" class="systemInfo">None</div>
          <div id="selectedOwner" class="small"></div>
          <div id="selectedIncome" class="small"></div>
          <div class="btnRow">
            <button id="buildFleet">Build Fleet (Cost: <span id="buildCost">100</span>)</button>
            <button id="sendFleet">Send Fleet</button>
          </div>
        </div>
        <div class="panel">
          <div class="small">Zoom</div>
          <input id="zoomSlider" type="range" min="0.5" max="2.5" step="0.05" value="1">
          <div class="small" style="margin-top:6px">Minimap</div>
          <canvas id="minimap" width="200" height="120"></canvas>
        </div>
      </div>

      <div id="canvasWrap">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div id="footer" style="display:none">
        <div class="legend">
          <div class="dot" style="background:#4ea3ff"></div><div class="small">Player</div>
          <div class="dot" style="background:#b0b8c6"></div><div class="small">Neutral</div>
          <div class="dot" style="background:#ff6b6b"></div><div class="small">AI</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===== Galactic Conquest RTS - Single HTML File =====
   Features implemented:
   - Main menu with AI difficulty and number-of-systems slider (5-300)
   - Procedural galaxy with sectors and systems; sector borders & color-coding
   - Starlanes connecting systems (graph), color-coded by owner, highlighted on hover
   - Fleets (triangles), buildable in owned systems; send fleets with pathfinding
   - Fleet movement animation along starlanes; merging; combat resolution
   - Elaborate economy: systems produce income; costs for building fleets; build queues
   - AI competitor with adjustable difficulty; simple decision-making
   - Zoom & pan, minimap, return to main menu, win conditions
*/

// ---------- Utilities ----------
function rand(seed) {
  // deterministic random using xorshift-ish from seed string
  let h = 2166136261 >>> 0;
  for (let i=0;i<seed.length;i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
  return function(){
    h += 0x6D2B79F5;
    let t = Math.imul(h ^ h >>> 15, 1 | h);
    t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function choice(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }
function lerp(a,b,t){return a+(b-a)*t}
function dist(a,b){let dx=a.x-b.x,dy=a.y-b.y;return Math.hypot(dx,dy);} 
function clamp(v,a,b){return Math.max(a, Math.min(b, v));}

// Simple name generator
const SYLL = ["sol","ar","ta","ri","zen","kor","nal","vex","lon","or","ima","tur","sha","bel","tek","zar","ion","qua","dra","lyr","neo","exa","pon","mar","vel","stel"]; 
function makeName(rng, parts=2){let s="";for(let i=0;i<parts;i++) s+=choice(rng,SYLL); return s.charAt(0).toUpperCase()+s.slice(1);} 

// Convex hull (Graham scan)
function convexHull(points){ if(points.length<3) return points.slice(); let pts = points.slice().sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x); }
  let lower=[]; for(let p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  let upper=[]; for(let i=pts.length-1;i>=0;i--){ let p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop(); return lower.concat(upper);
}

// ---------- Game Classes ----------
class SystemNode{
  constructor(id,x,y,sector,name){
    this.id=id; this.x=x; this.y=y; this.sector=sector; this.name=name;
    this.owner=0; // 0 neutral, 1 player, 2 ai
    this.defense= Math.floor(10 + Math.random()*20); // garrison strength
    this.production = Math.max(1, Math.floor(5 + Math.random()*15)); // credits/sec base
    this.buildQueue=0; // build progress in seconds
    this.connected=[]; // neighbors ids
  }
}
class Sector{
  constructor(id,color,name){ this.id=id; this.color=color; this.name=name; this.systems=[]; this.owner=0; }
}
class Fleet{
  constructor(id,owner,strength,originNode){
    this.id=id; this.owner=owner; this.strength=strength; this.path=[]; this.origin=originNode; this.currentNode=originNode; this.progress=0; this.speed=15 + Math.random()*0.8; // units per second along edge
    this.moving=false; this._from=null; this._to=null; this.pos={x:originNode.x,y:originNode.y};
  }
}

// ---------- Game Manager ----------
const G = {
  rng: Math.random,
  systems:[], sectors:[], fleets:[], edges:[], sectorColors:[], players: {1:{credits:200, income:0}, 2:{credits:200, income:0}},
  settings:{systems:60, difficulty:1.0, seed:null},
  time:0, running:false, selectedSystem:null, selectedFleet:null, sendMode:false,
  view:{x:0,y:0,scale:1}, canvas:null, ctx:null, minimapCtx:null,
  nextFleetId:1, nextSystemId:1,
}

function resetGame(){ G.systems=[];G.sectors=[];G.fleets=[];G.edges=[];G.players={1:{credits:200,income:0},2:{credits:200,income:0}};G.nextFleetId=1;G.nextSystemId=1;G.time=0; G.selectedSystem=null; G.selectedFleet=null; G.sendMode=false; }

// Procedural galaxy generation
function generateGalaxy(settings){ resetGame();
  const seed = settings.seed || Math.random().toString(36).slice(2);
  G.rng = rand(seed + 'galaxy');
  const rng = G.rng;
  const W = 3000, H = 1800; // logical galaxy size
  const total = settings.systems;
  // choose number of sectors
  const minS = Math.max(2, Math.floor(total/50));
  const maxS = Math.min(12, Math.max(3, Math.floor(total/8)));
  const sectorsCount = Math.floor(lerp(minS,maxS, rng()));
  // create sectors with centers
  let sectorCenters=[];
  for(let i=0;i<sectorsCount;i++){
    let cx = 200 + rng()*(W-400);
    let cy = 200 + rng()*(H-400);
    sectorCenters.push({x:cx,y:cy});
    const colorHue = Math.floor(rng()*360);
    const color = `hsl(${colorHue}deg 70% 55% / 0.25)`; // fill alpha
    const name = makeName(rng,2) + ' Sector';
    G.sectors.push(new Sector(i, color, name));
  }
  // distribute systems into sectors
  let assigned = 0;
  for(let i=0;i<sectorsCount;i++){
    // random size distribution
    let remaining = total - assigned;
    let remainingSectors = sectorsCount - i;
    let take = Math.max(1, Math.floor(rng()*(remaining/remainingSectors*1.6))); // variable
    if(i===sectorsCount-1) take = remaining;
    assigned += take;
    for(let s=0;s<take;s++){
      const jitter = 80 + rng()*200;
      const ang = rng()*Math.PI*2;
      const cx = sectorCenters[i].x + Math.cos(ang)*rng()*jitter;
      const cy = sectorCenters[i].y + Math.sin(ang)*rng()*jitter;
      const sys = new SystemNode(G.nextSystemId++, cx, cy, i, makeName(rng,1 + Math.round(rng()*2)));
      G.systems.push(sys);
      G.sectors[i].systems.push(sys);
    }
  }
  // create edges: connect near neighbors using k-nearest
  const k = 3;
  for(let a of G.systems){
    let dists = G.systems.map(b=>({b, d: dist(a,b)})).filter(o=>o.b!==a).sort((x,y)=>x.d-y.d);
    for(let i=0;i<Math.min(k,dists.length);i++){
      const b = dists[i].b;
      addEdge(a,b);
    }
  }
  // Make sure graph is connected: join clusters
  ensureConnected();
  // Add some cross-sector starlanes between sectors
  for(let i=0;i<G.sectors.length;i++){
    for(let j=i+1;j<G.sectors.length;j++){
      if(rng()<0.35){ // some links
        const a = choice(rng, G.sectors[i].systems);
        const b = choice(rng, G.sectors[j].systems);
        addEdge(a,b);
      }
    }
  }
  // Build sector hulls
  for(let sec of G.sectors){
    sec.hull = convexHull(sec.systems.map(s=>({x:s.x,y:s.y}))).map(p=>({x:p.x,y:p.y}));
  }
  // initial ownership: pick 1 player system and 1 AI system
  // choose core systems near center
  G.systems.sort((a,b)=>Math.hypot(a.x-W/2,a.y-H/2)-Math.hypot(b.x-W/2,b.y-H/2));
  let playerStart = G.systems[0]; playerStart.owner=1; playerStart.defense=20; playerStart.production+=10;
  let aiStart = G.systems[Math.floor(G.systems.length/2)]; aiStart.owner=2; aiStart.defense=18; aiStart.production+=8;
  // some random neutral defenses
  for(let s of G.systems){ if(s.owner===0){ if(rng()<0.15) s.defense += Math.floor(rng()*15);}}
  // assign colors for sectors default
  for(let sec of G.sectors) sec.owner=0;
  // initial incomes
  recalcIncome();
  // set view center
  G.view.x = W/2; G.view.y = H/2; G.view.scale = 0.6;
  G.width=W; G.height=H; G.seed = seed;
  // done
}

function addEdge(a,b){ if(a.id===b.id) return; // prevent duplicates
  // avoid adding duplicates
  for(let e of G.edges){ if((e.a===a&&e.b===b)||(e.a===b&&e.b===a)) return; }
  G.edges.push({a:a,b:b});
  a.connected.push(b); b.connected.push(a);
}

function ensureConnected(){
  // union-find to connect
  const parent = new Map();
  function find(x){ if(!parent.has(x)) parent.set(x,x); if(parent.get(x)!==x) parent.set(x, find(parent.get(x))); return parent.get(x);} 
  function union(a,b){ parent.set(find(a), find(b)); }
  // init
  for(let s of G.systems) parent.set(s,s);
  for(let e of G.edges) union(e.a, e.b);
  // group
  let groups = {}; for(let s of G.systems){ let g=find(s); if(!groups[g.id]) groups[g.id]=[]; groups[g.id].push(s);}  
  let comps = Object.values(groups);
  if(comps.length<=1) return;
  // connect components
  for(let i=0;i<comps.length-1;i++){
    let a = comps[i][0]; let b = comps[i+1][0]; addEdge(a,b);
  }
}

function recalcIncome(){ G.players[1].income=0; G.players[2].income=0; for(let s of G.systems){ if(s.owner===1) G.players[1].income += s.production; if(s.owner===2) G.players[2].income += s.production; }}

// ---------- Game Loop & Logic ----------
function tick(dt){
  if(!G.running) return;
  G.time += dt;
  // economy update (continuous)
  // Add credits per second
  G.players[1].credits += G.players[1].income * dt;
  G.players[2].credits += G.players[2].income * dt * G.settings.difficulty; // AI scaling
  // build queues: instantly create fleets but cost paid
  // fleets movement
  for(let f of G.fleets){
    if(f.moving && f._from && f._to){
      const from = f._from; const to = f._to;
      const edgeLen = dist(from,to);
      f.progress += f.speed * dt * 100 / edgeLen; // normalized
      // position
      const t = clamp(f.progress/100,0,1);
      f.pos.x = lerp(from.x,to.x,t);
      f.pos.y = lerp(from.y,to.y,t);
      if(f.progress>=100){ // arrive
        f.currentNode = to; f.moving=false; f._from=null; f._to=null; f.progress=0;
        f.pos.x = f.currentNode.x; f.pos.y = f.currentNode.y;
        // handle combat/conquest
        resolveArrival(f);
      }
    }
  }
  // merge fleets at nodes (same owner)
  mergeFleetsAtNodes();
  // AI decision making
  aiBehavior(dt);
  // update UI
  recalcIncome();
  draw();
  checkWinConditions();
}

function resolveArrival(f){
  const node = f.currentNode;
  if(node.owner === f.owner){ // landing on own system -> add to garrison
    node.defense += Math.round(f.strength*0.7);
    // remove fleet
    removeFleet(f);
    return;
  }
  // attacking enemy or neutral
  const defense = node.defense;
  if(f.strength >= defense){
    // conquer
    const leftover = f.strength - defense;
    node.owner = f.owner;
    node.defense = Math.max(1, Math.round(leftover*0.6));
    // transfer production modifiers
    // remove fleet
    removeFleet(f);
  } else {
    // fleet destroyed, defenders reduced
    node.defense = Math.max(0, node.defense - Math.round(f.strength*0.7));
    removeFleet(f);
  }
}

function mergeFleetsAtNodes(){
  const map = new Map();
  for(let f of G.fleets){ if(!f.moving){ let key=f.currentNode.id+"-"+f.owner; if(!map.has(key)) map.set(key,[]); map.get(key).push(f); }}
  for(let [k, arr] of map){ if(arr.length>1){ let target = arr[0]; for(let i=1;i<arr.length;i++){ target.strength += arr[i].strength; removeFleet(arr[i]); } }}
}
function removeFleet(f){ const idx=G.fleets.indexOf(f); if(idx>=0) G.fleets.splice(idx,1); }

// ---------- AI ----------
function aiBehavior(dt){
  // simple timer based actions
  if(!G._aiTimer) G._aiTimer=0; G._aiTimer += dt;
  const thinkInterval = 1.0 / G.settings.difficulty; // harder -> more frequent
  if(G._aiTimer < thinkInterval) return; G._aiTimer=0;
  // decide to build at owned systems with highest production
  const aiSystems = G.systems.filter(s=>s.owner===2);
  if(aiSystems.length===0) return;
  // pick the system with highest production that has relatively low defense and enough credits
  aiSystems.sort((a,b)=>b.production - a.production);
  const best = aiSystems[0];
  // build probability depends on difficulty
  if(Math.random() < 0.7 * (0.6 + 0.4*G.settings.difficulty)){
    const cost = buildCost(1);
    if(G.players[2].credits >= cost){ G.players[2].credits -= cost; const fleet=new Fleet(G.nextFleetId++,2,1,best); G.fleets.push(fleet); }
  }
  // send fleets: if any fleet present and there exist nearby non-owned systems, send
  const aiFleets = G.fleets.filter(f=>f.owner===2 && !f.moving);
  for(let f of aiFleets){
    // find nearest target neutral or player
    let target = findNearestTarget(f.currentNode, 2);
    if(target){ const path = findPath(f.currentNode, target); if(path.length>1){ sendFleetAlong(f, path); break; } }
  }
}

function findNearestTarget(node, owner){
  let best=null; let bestD=1e9;
  for(let s of G.systems){ if(s.owner===owner) continue; let d = dist(node, s); if(d<bestD){ bestD=d; best=s; }} return best;
}

// ---------- UI & Interaction ----------
function setupUI(){
  const canvas = document.getElementById('gameCanvas'); G.canvas=canvas; G.ctx=canvas.getContext('2d');
  const minimap = document.getElementById('minimap'); G.minimapCtx=minimap.getContext('2d');
  function resize(){ canvas.width = window.innerWidth - 320; canvas.height = window.innerHeight - 40; }
  window.addEventListener('resize', resize); resize();
  // menu handlers
  const sysRange = document.getElementById('systemsRange'); const sysCount = document.getElementById('sysCount'); sysRange.addEventListener('input', ()=>{ sysCount.textContent = sysRange.value; });
  document.getElementById('launchBtn').addEventListener('click', ()=>{
    const diff = parseFloat(document.getElementById('difficulty').value);
    const systems = parseInt(document.getElementById('systemsRange').value,10);
    const seed = document.getElementById('seed').value.trim() || null;
    startGame({systems:systems, difficulty:diff, seed:seed});
  });
  document.getElementById('loadExample').addEventListener('click', ()=>{ document.getElementById('systemsRange').value=80; document.getElementById('sysCount').textContent=80; document.getElementById('difficulty').value=1.0; document.getElementById('seed').value='example-42'; });
  document.getElementById('toMenu').addEventListener('click', ()=>{ stopGame(); });
  document.getElementById('buildFleet').addEventListener('click', ()=>{ buildFleetCommand(); });
  document.getElementById('sendFleet').addEventListener('click', ()=>{ if(G.selectedFleet) { G.sendMode=true; document.getElementById('sendFleet').textContent='Click destination'; } else { alert('Select a fleet first (click a triangle)'); }});
  document.getElementById('zoomSlider').addEventListener('input', (e)=>{ G.view.scale = parseFloat(e.target.value); draw(); });
  // canvas interactions
  let isRightDown=false; let lastX=0,lastY=0;
  canvas.addEventListener('mousedown', (ev)=>{
    const pos = screenToWorld(ev.offsetX, ev.offsetY);
    if(ev.button===2){ isRightDown=true; lastX=ev.clientX; lastY=ev.clientY; }
    else handleLeftClick(pos, ev);
  });
  canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
  canvas.addEventListener('mouseup', (ev)=>{ if(ev.button===2) isRightDown=false; });
  window.addEventListener('mousemove', (ev)=>{ if(isRightDown){ const dx=(lastX-ev.clientX)/G.view.scale; const dy=(lastY-ev.clientY)/G.view.scale; G.view.x += dx; G.view.y += dy; lastX=ev.clientX; lastY=ev.clientY; draw(); }});
  canvas.addEventListener('wheel', (ev)=>{ ev.preventDefault(); const prev = G.view.scale; const delta = -ev.deltaY * 0.001; G.view.scale = clamp(G.view.scale * (1+delta), 0.3, 2.8); document.getElementById('zoomSlider').value = G.view.scale; draw(); });
}

function screenToWorld(sx,sy){ const rect = G.canvas.getBoundingClientRect(); const x = (sx - 0)/G.view.scale + (G.view.x - G.canvas.width/2/G.view.scale); const y = (sy - 0)/G.view.scale + (G.view.y - G.canvas.height/2/G.view.scale); return {x,y}; }
function worldToScreen(wx,wy){ const sx = ( (wx - (G.view.x - G.canvas.width/2/G.view.scale)) ) * G.view.scale; const sy = ( (wy - (G.view.y - G.canvas.height/2/G.view.scale)) ) * G.view.scale; return {x:sx,y:sy}; }

function handleLeftClick(pos, ev){ // select system or fleet or send destination
  // find nearest system within threshold
  let nearest=null; let nd=999999;
  for(let s of G.systems){ const d = Math.hypot(s.x-pos.x, s.y-pos.y); if(d<nd){ nd=d; nearest=s; }}
  const thresh = 18 / G.view.scale;
  // check fleet click first
  for(let f of G.fleets){ const d = Math.hypot(f.pos.x-pos.x, f.pos.y-pos.y); if(d < 14 / G.view.scale){ // select fleet
      G.selectedFleet = f; G.sendMode=false; document.getElementById('sendFleet').textContent='Send Fleet'; updateSelectionUI(); draw(); return; }
  }
  if(G.sendMode && G.selectedFleet && nearest){ // attempt to send fleet along path
    const path = findPath(G.selectedFleet.currentNode, nearest);
    if(path.length>1){ sendFleetAlong(G.selectedFleet, path); G.sendMode=false; document.getElementById('sendFleet').textContent='Send Fleet'; updateSelectionUI(); draw(); }
    else{ alert('No route to destination'); }
    return;
  }
  if(nearest && nd < thresh){ // select system
    G.selectedSystem = nearest; G.selectedFleet=null; updateSelectionUI(); draw();
  } else { G.selectedSystem=null; G.selectedFleet=null; updateSelectionUI(); draw(); }
}

function updateSelectionUI(){ if(G.selectedSystem){ document.getElementById('selectedName').textContent = G.selectedSystem.name; document.getElementById('selectedOwner').textContent = 'Owner: ' + ownerName(G.selectedSystem.owner); document.getElementById('selectedIncome').textContent = 'Income: ' + G.selectedSystem.production + '/s, Defense: ' + G.selectedSystem.defense; } else { document.getElementById('selectedName').textContent = 'None'; document.getElementById('selectedOwner').textContent=''; document.getElementById('selectedIncome').textContent=''; }
  document.getElementById('credits').textContent = Math.floor(G.players[1].credits);
  document.getElementById('income').textContent = Math.floor(G.players[1].income);
  document.getElementById('timeLabel').textContent = Math.floor(G.time) + 's';
}

function ownerName(o){ return o===0?'Neutral': o===1? 'Player': 'AI'; }

// Build fleet command
function buildFleetCommand(){ const s = G.selectedSystem; if(!s || s.owner!==1){ alert('Select a system you control to build a fleet.'); return; }
  const cost = buildCost(1);
  if(G.players[1].credits < cost){ alert('Not enough credits'); return; }
  G.players[1].credits -= cost; const fleet = new Fleet(G.nextFleetId++,1,1,s); G.fleets.push(fleet); updateSelectionUI(); draw(); }
function buildCost(units){ return Math.floor(60 * Math.pow(1.08, units-1)); }

// send fleet along path (array of nodes)
function sendFleetAlong(f, path){ if(path.length<2) return; // path is nodes
  // convert to edges along path, set f._from and _to as first step
  f.path = path;
  if(f.currentNode !== path[0]){ // ensure current
    // may need to reposition
    f.currentNode = path[0];
    f.pos.x = path[0].x; f.pos.y = path[0].y;
  }
  // remove f from node? we'll set moving
  const next = path[1]; f._from = path[0]; f._to = next; f.moving=true; f.progress=0; }

// pathfinding: BFS on nodes
function findPath(a,b){ if(a===b) return [a]; let q=[a]; const prev=new Map(); prev.set(a,a); while(q.length){ let cur=q.shift(); for(let n of cur.connected){ if(prev.has(n)) continue; prev.set(n,cur); if(n===b){ // reconstruct
      let path=[n]; let p=cur; while(p!==a){ path.unshift(p); p=prev.get(p); } path.unshift(a); return path; } q.push(n); }} return []; }

// ---------- Drawing ----------
function draw(){ const ctx = G.ctx; const canvas = G.canvas; ctx.clearRect(0,0,canvas.width,canvas.height);
  // background grid
  ctx.fillStyle='#061322'; ctx.fillRect(0,0,canvas.width,canvas.height);
  // draw sectors (hull polygons)
  for(let sec of G.sectors){ if(!sec.hull || sec.hull.length<3) continue; ctx.save(); ctx.globalAlpha = 0.15; ctx.fillStyle = sec.color; ctx.beginPath(); for(let i=0;i<sec.hull.length;i++){ const p=sec.hull[i]; const s = worldToScreen(p.x,p.y); if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); } ctx.closePath(); ctx.fill(); ctx.restore(); }
  // draw edges (starlanes)
  for(let e of G.edges){ const sa = worldToScreen(e.a.x,e.a.y), sb = worldToScreen(e.b.x,e.b.y);
    // lane color based on majority owner of endpoints
    let owner = laneOwner(e);
    ctx.beginPath(); ctx.lineWidth = Math.max(1, 2 * G.view.scale);
    ctx.strokeStyle = owner===0? 'rgba(160,170,190,0.14)' : owner===1? 'rgba(78,163,255,0.9)' : 'rgba(255,107,107,0.9)';
    ctx.moveTo(sa.x, sa.y); ctx.lineTo(sb.x, sb.y); ctx.stroke(); }

  // draw systems
  for(let s of G.systems){ const sc = worldToScreen(s.x,s.y);
    // circle
    ctx.beginPath(); ctx.arc(sc.x, sc.y, Math.max(4, 6*G.view.scale), 0, Math.PI*2);
    const fill = s.owner===0? '#b0b8c6' : s.owner===1? '#4ea3ff' : '#ff6b6b';
    ctx.fillStyle = fill; ctx.fill();
    // outline
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke();
    // small production text
    ctx.fillStyle = 'rgba(220,230,255,0.9)'; ctx.font = `${10*G.view.scale}px sans-serif`;
    ctx.fillText(s.name, sc.x + 8*G.view.scale, sc.y - 6*G.view.scale);
  }
  // draw sector names
  for(let sec of G.sectors){ if(sec.systems.length){ const avgX = sec.systems.reduce((a,b)=>a+b.x,0)/sec.systems.length; const avgY = sec.systems.reduce((a,b)=>a+b.y,0)/sec.systems.length; const p=worldToScreen(avgX,avgY); ctx.font = `${12*G.view.scale}px sans-serif`; ctx.fillStyle='rgba(200,220,255,0.6)'; ctx.fillText(sec.name, p.x-20, p.y-8); }}
  // draw fleets
  for(let f of G.fleets){ const p = worldToScreen(f.pos.x,f.pos.y);
    drawTriangle(ctx, p.x, p.y, f); // orientation based on movement
    // strength label
    ctx.fillStyle='white'; ctx.font = `${11*G.view.scale}px sans-serif`; ctx.fillText(f.strength, p.x+6, p.y-6);
  }
  // highlight selected system
  if(G.selectedSystem){ const s = G.selectedSystem; const sc = worldToScreen(s.x,s.y); ctx.beginPath(); ctx.arc(sc.x, sc.y, 12*G.view.scale,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth = 2; ctx.stroke(); }
  // highlight selected fleet
  if(G.selectedFleet){ const f=G.selectedFleet; const p=worldToScreen(f.pos.x,f.pos.y); ctx.beginPath(); ctx.arc(p.x,p.y,12*G.view.scale,0,Math.PI*2); ctx.strokeStyle='yellow'; ctx.lineWidth=2; ctx.stroke(); }
  // minimap
  drawMinimap();
}

function drawTriangle(ctx,x,y,f){ ctx.save(); ctx.translate(x,y);
  let angle = 0; if(f.moving && f._from && f._to){ angle = Math.atan2(f._to.y - f._from.y, f._to.x - f._from.x); }
  ctx.rotate(angle);
  ctx.beginPath(); ctx.moveTo(8*G.view.scale,0); ctx.lineTo(-6*G.view.scale,4*G.view.scale); ctx.lineTo(-6*G.view.scale,-4*G.view.scale); ctx.closePath();
  ctx.fillStyle = f.owner===1? '#4ea3ff' : '#ff6b6b'; ctx.fill(); ctx.restore();
}

function laneOwner(edge){ // determine color/owner based on endpoints
  if(edge.a.owner===edge.b.owner) return edge.a.owner; if(edge.a.owner===1 || edge.b.owner===1) return 1; if(edge.a.owner===2 || edge.b.owner===2) return 2; return 0; }

function drawMinimap(){ const ctx = G.minimapCtx; const w=200,h=120; ctx.clearRect(0,0,w,h); ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(0,0,w,h);
  // scale factor
  const fx = w / G.width; const fy = h / G.height;
  for(let e of G.edges){ ctx.beginPath(); ctx.moveTo(e.a.x*fx,e.a.y*fy); ctx.lineTo(e.b.x*fx,e.b.y*fy); ctx.strokeStyle='rgba(200,200,220,0.15)'; ctx.stroke(); }
  for(let s of G.systems){ ctx.fillStyle = s.owner===1? '#4ea3ff' : s.owner===2? '#ff6b6b' : '#b0b8c6'; ctx.fillRect(s.x*fx-1,s.y*fy-1,2,2); }
}

// ---------- Win Conditions ----------
function checkWinConditions(){ const playerSystems = G.systems.filter(s=>s.owner===1).length; const aiSystems = G.systems.filter(s=>s.owner===2).length; const playerFleets = G.fleets.filter(f=>f.owner===1).length; const aiFleets = G.fleets.filter(f=>f.owner===2).length;
  if(aiSystems===0 && aiFleets===0){ alert('You Win!'); stopGame(); }
  if(playerSystems===0 && playerFleets===0){ alert('AI Wins!'); stopGame(); }
}

// ---------- Start/Stop ----------
let rafId=null; let lastTime = performance.now();
function startGame(settings){ G.settings = settings; generateGalaxy(settings); G.running=true; // UI switch
  document.getElementById('menu').style.display='none'; document.getElementById('topBar').style.display='flex'; document.getElementById('hud').style.display='block'; document.getElementById('footer').style.display='block';
  document.getElementById('statusText').textContent = 'Running — Seed: ' + (G.seed||'random');
  // credit balance initial
  G.players[1].credits = 300; G.players[2].credits = 300 * G.settings.difficulty;
  // place a few starting fleets
  const pStart = G.systems.find(s=>s.owner===1); if(pStart){ G.fleets.push(new Fleet(G.nextFleetId++,1,2,pStart)); }
  const aiStart = G.systems.find(s=>s.owner===2); if(aiStart){ G.fleets.push(new Fleet(G.nextFleetId++,2,2,aiStart)); }
  // game loop
  lastTime = performance.now(); function loop(t){ const dt = Math.min(0.1, (t-lastTime)/1000); lastTime = t; tick(dt); rafId = requestAnimationFrame(loop); }
  rafId = requestAnimationFrame(loop);
}

function stopGame(){ G.running=false; cancelAnimationFrame(rafId); document.getElementById('menu').style.display='block'; document.getElementById('topBar').style.display='none'; document.getElementById('hud').style.display='none'; document.getElementById('footer').style.display='none'; }

// ---------- Init ----------
setupUI(); // initial draw
// small example
G.settings.systems = 60; generateGalaxy(G.settings); draw();

</script>
</body>
</html>
