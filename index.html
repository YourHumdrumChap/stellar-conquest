<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galactic Conquest — RTS Prototype (Fixed AI Colors)</title>
  <style>
    :root{--bg:#071025;--panel:#0f1626;--accent:#4ea3ff;--accent2:#ff6b6b;--muted:#98a0b3}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#dbe6ff;background:linear-gradient(180deg,#031020 0%, #05122a 70%);}
    #container{display:flex;height:100vh;gap:12px;padding:14px;box-sizing:border-box}
    #leftPane{width:300px;flex-shrink:0}
    #menu,#settings{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    h1{font-size:18px;margin:0 0 12px 0}
    label{display:block;margin-top:8px;font-size:13px;color:var(--muted)}
    input[type=range], input[type=number]{width:100%}
    select,button,input{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button.primary{background:linear-gradient(90deg,var(--accent),#2ec4ff);color:#021022;border:none;font-weight:600}
    #gameArea{flex:1;position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#061122,#071426)}
    #topBar{position:absolute;left:12px;top:12px;z-index:50;background:rgba(5,8,15,0.6);padding:8px;border-radius:8px;display:flex;gap:8px;align-items:center}
    #hud{position:absolute;right:12px;top:12px;z-index:50;background:rgba(5,8,15,0.6);padding:8px;border-radius:8px;min-width:260px}
  /* Ensure HUD controls receive pointer events even if canvas is underneath */
  #hud, #hud * { pointer-events: auto; }
    #canvasWrap{width:100%;height:100%;display:flex}
    canvas#gameCanvas{flex:1;display:block;cursor:crosshair}
    .panel{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    .systemInfo{font-size:13px;margin-top:8px}
    .btnRow{display:flex;gap:8px;margin-top:8px}
    .controlBtn{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    #footer{position:absolute;left:12px;bottom:12px;z-index:20;color:var(--muted);font-size:12px}
    .legend{display:flex;gap:8px;align-items:center}
    .legend .dot{width:12px;height:12px;border-radius:3px}
    #minimap{width:200px;height:120px;border-radius:8px;background:rgba(0,0,0,0.12);margin-top:8px}
    .progressBar{height:8px;background:rgba(255,255,255,0.06);border-radius:6px;overflow:hidden}
    .progressFill{height:100%;background:linear-gradient(90deg,var(--accent),#2ec4ff);width:0%}
    @media (max-width:900px){#leftPane{display:none}}
  </style>
</head>
<body>
  <div id="container">
    <!-- UI Toggle Floating Button -->
    <div id="uiToggleBtn" title="Toggle UI Panel" style="position:fixed;right:18px;bottom:18px;z-index:120;background:linear-gradient(90deg,var(--accent),#2ec4ff);color:#021022;padding:8px;border-radius:10px;cursor:pointer;box-shadow:0 8px 20px rgba(0,0,0,0.5)">UI</div>
    <div id="uiTogglePanel" style="position:fixed;right:18px;bottom:70px;z-index:120;background:rgba(2,6,12,0.85);color:#dbe6ff;padding:10px;border-radius:8px;display:none;min-width:200px">
      <div style="font-weight:600;margin-bottom:6px">UI Controls</div>
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="toggleLeftPane" checked /> Show Left Pane</label>
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="toggleDevConsole" checked /> Show Dev Console</label>
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="toggleHUD" checked /> Show HUD</label>
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="toggleFooter" checked /> Show Footer</label>
      <div class="small" style="margin-top:8px">Shortcuts: <strong>U</strong> toggles this panel</div>
    </div>
    <div id="leftPane">
      <div id="menu">
        <h1>Galactic Conquest</h1>
        <div class="small">A lightweight real-time strategy prototype — HTML + JS. Configure and Launch.</div>

        <label for="difficulty">AI Difficulty</label>
        <select id="difficulty">
          <option value="0.6">Very Easy</option>
          <option value="0.8">Easy</option>
          <option value="1.0" selected>Normal</option>
          <option value="1.25">Hard</option>
          <option value="1.6">Very Hard</option>
          <option value="2.2">Insane</option>
        </select>

        <label for="aiCount">Number of AI Opponents <span id="aiCountLabel">3</span></label>
        <input id="aiCount" type="range" min="1" max="100" value="3">

        <label for="systemsRange">Number of Star Systems <span id="sysCount">120</span></label>
        <input id="systemsRange" type="range" min="5" max="1000" value="120">

        <label for="seed">Galaxy Seed (optional)</label>
        <input id="seed" placeholder="leave blank for random" />

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="launchBtn" class="primary">Launch</button>
          <button id="spectateBtn">Spectate AI Game</button>
          <button id="loadExample">Example</button>
        </div>

        <div class="panel">
          <div class="small">Controls</div>
          <ul class="small">
            <li>Click a system to select it.</li>
            <li>Build fleets in controlled systems that have a shipyard.</li>
            <li>Drag to select fleets, click "Send Fleet", then click destination.</li>
            <li>Zoom with mouse wheel. Pan with right-drag (hold RMB).</li>
          </ul>
        </div>
      </div>

      <div id="settings" style="margin-top:12px">
        <div class="small">Tips</div>
        <div class="small systemInfo" id="tipsText">Capture systems, build mines to increase income, build shipyards to produce fleets. AI difficulty affects budget and aggressiveness.</div>
      </div>
    </div>

    <div class="panel" id="devConsolePanel" style="margin:12px">
      <div class="small">Dev Console (testing)</div>
      <div style="margin-top:8px">
        <textarea id="devConsoleInput" placeholder="Type command, e.g. 'credits 1000' or 'spawn 12 3 2'" style="width:100%;height:64px;border-radius:6px;padding:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit;font-family:monospace"></textarea>
        <div style="display:flex;gap:8px;margin-top:6px">
          <button id="devConsoleRun">Run</button>
          <button id="devConsoleClear">Clear</button>
          <button id="devConsoleFillExample">Example</button>
        </div>
        <pre id="devConsoleOutput" style="margin-top:8px;height:120px;overflow:auto;background:rgba(0,0,0,0.08);padding:8px;border-radius:6px;font-family:monospace;font-size:12px;color:var(--muted)"></pre>
      </div>
    </div>

    <div id="gameArea">
      <div id="topBar" style="display:none">
        <button id="toMenu">Main Menu</button>
        <div class="small" id="statusText">Status:</div>
      </div>

      <div id="hud" style="display:none">
        <div class="small">Credits: <span id="credits">0.0</span></div>
        <div class="small">Income/sec: <span id="income">0.0</span></div>
        <div class="small">Time: <span id="timeLabel">0s</span></div>

        <div class="panel">
          <div class="small">Selected</div>
          <div id="selectedName" class="systemInfo">None</div>
          <div id="selectedOwner" class="small"></div>
          <div id="selectedIncome" class="small"></div>
          <div class="btnRow">
            <div style="flex:1;display:flex;gap:8px;align-items:center">
              <button id="buildMine">Build Mine (Cost: <span id="mineCost">100</span>)</button>
              <button id="buildShipyard">Build Shipyard (Cost: <span id="yardCost">300</span>)</button>
              <button id="buildOutpost">Build Outpost (Cost: <span id="outpostCost">2500</span>)</button>
            </div>
            <div style="width:90px;display:flex;flex-direction:column;align-items:center;justify-content:center">
              <label class="small" style="margin:0;font-size:11px">Count</label>
              <input id="buildCount" type="number" value="1" min="1" step="1" style="width:66px;padding:6px" />
            </div>
          </div>
          <div style="margin-top:8px" class="small">Build Queue</div>
          <div id="buildQueue"></div>
        </div>

        <div class="panel">
          <div class="small">Fleets</div>
          <div class="small">Selected Fleets: <span id="selFleetCount">0</span></div>
          <div class="btnRow" style="margin-top:8px">
            <button id="buildFleet">Build Fleet (Cost: <span id="buildCost">150</span>)</button>
            <button id="sendFleet">Send Fleet</button>
            <button id="autoCapture" title="Automatically capture a chain of weak nearby systems">Auto Capture</button>
            <button id="stopAutoCapture" title="Stop Auto Capture on selected fleets">Stop Auto</button>
          </div>
          <div style="margin-top:6px;display:flex;gap:8px;align-items:center">
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="acIncludeNeutral" checked /> Include Neutrals</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="acIncludeAI" checked /> Include AIs</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="acStopIfSuicidal" /> Stop before suicidal attack</label>
          </div>
        </div>

        <div class="panel">
          <div class="small">Zoom</div>
          <input id="zoomSlider" type="range" min="0.3" max="2.5" step="0.05" value="1">
          <div class="small" style="margin-top:6px">Minimap</div>
          <canvas id="minimap" width="200" height="120"></canvas>
        </div>
      </div>

      <div id="canvasWrap">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div id="footer" style="display:none">
        <div class="legend">
          <div class="dot" style="background:#4ea3ff"></div><div class="small">Player</div>
          <div class="dot" style="background:#b0b8c6"></div><div class="small">Neutral</div>
          <!-- this dot will be updated to a multi-color gradient for AI colors -->
          <div class="dot" id="aiLegendDot" style="background:linear-gradient(90deg,#ff6b6b,#ff9f6b)"></div><div class="small">AI</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===== Galactic Conquest RTS - AI color distribution fixes ===== */

/* ===== Utilities ===== */
function seededRNG(seed){
  seed = String(seed || '');
  let h = 2166136261 >>> 0;
  for(let i=0;i<seed.length;i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
  return function(){
    h += 0x6D2B79F5;
    let t = Math.imul(h ^ (h >>> 15), 1 | h);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
function choice(rng,arr){ return arr[Math.floor(rng()*arr.length)]; }
function lerp(a,b,t){ return a + (b-a)*t; }
function dist(a,b){ let dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function randDecimal(rng,min,max){ return Math.round((min + rng()*(max-min))*10)/10; }
const SYLL = ["sol","ar","ta","ri","zen","kor","nal","vex","lon","or","ima","tur","sha","bel","tek","zar","ion","qua","dra","lyr","neo","exa","pon","mar","vel","stel"];
function makeName(rng, parts=2){ let s=""; for(let i=0;i<parts;i++) s += choice(rng,SYLL); return s.charAt(0).toUpperCase() + s.slice(1); }
function pointLineDist(px,py,x1,y1,x2,y2){ const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1; const dot = A*C + B*D; const len2 = C*C + D*D; let t = len2 === 0 ? 0 : dot / len2; t = Math.max(0, Math.min(1, t)); const projx = x1 + C * t, projy = y1 + D * t; return Math.hypot(px - projx, py - projy); }

/* Convex hull */
function convexHull(points){ if(points.length<3) return points.slice(); let pts = points.slice().sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x); function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x); } let lower=[]; for(let p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); } let upper=[]; for(let i=pts.length-1;i>=0;i--){ let p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); } upper.pop(); lower.pop(); return lower.concat(upper); }

/* ===== Classes ===== */
class SystemNode{
  constructor(id,x,y,sector,name){
    this.id=id; this.x=x; this.y=y; this.sector=sector; this.name=name;
    this.owner=0;
    this.defense=0;
    this.baseProd=0;
    this.mines=0;         // number of mine buildings (0..3)
    this.mineBonus=0;     // total extra production from mines
    this.buildings={shipyard:false, outposts:0}; // shipyard + outposts
    this.queue=[];
    this.connected=[];
  }
}
class Sector{ constructor(id,color,name){ this.id=id; this.color=color; this.name=name; this.systems=[]; this.owner=0; this.hull=[]; } }
class Fleet{
  constructor(id,owner,strength,currentNode){
    this.id=id; this.owner=owner; this.strength=strength; this.currentNode=currentNode;
    this.pos={x:currentNode.x,y:currentNode.y}; this.moving=false; this._from=null; this._to=null; this.progress=0;
    this.speed=90 + Math.random()*30; this.path=[]; this.pathIndex=0;
  }
}

/* ===== Global State ===== */
const G = {
  rng: Math.random,
  systems:[], sectors:[], edges:[], fleets:[], players:{}, settings:{systems:120, difficulty:1.0, aiCount:3, seed:null},
  time:0, running:false, selectedSystem:null, selectedFleets:[], sendMode:false,
  view:{x:0,y:0,scale:1}, canvas:null, ctx:null, minimapCtx:null, hoverEdge:null, hoverNode:null,
  nextFleetId:1, nextSystemId:1, width:3000, height:1800,
  _selRect:null, _selStart:null, _suppressClick:0,
  playerHue: {} // will hold hue per player id (AI)
};

function resetGame(){
  G.systems=[]; G.sectors=[]; G.fleets=[]; G.edges=[]; G.players={}; G.nextFleetId=1; G.nextSystemId=1; G.time=0;
  G.selectedSystem=null; G.selectedFleets=[]; G.sendMode=false; G.hoverEdge=null;
  G.playerHue = {};
}

/* ===== Color helpers ===== */
function setPlayerHues(){
  // assign deterministic hues for each player with id >= 2 (AIs)
  // use golden-angle distribution so colors spread nicely
  G.playerHue[0] = null; // neutral
  G.playerHue[1] = 206;  // player's base hue (~blue)
  for(let pidStr in G.players){
    const pid = Number(pidStr);
    if(pid <= 1) continue;
    // index is stable because players are created sequentially (2,3,4,...)
    const index = pid - 2;
    const golden = 137.508; // degrees
    const hue = (index * golden) % 360;
    G.playerHue[pid] = hue;
  }

  // update the footer legend AI dot to show some AI colors (gradient)
  const aiDot = document.getElementById('aiLegendDot');
  if(aiDot){
    const aiHues = Object.keys(G.players).map(p=>Number(p)).filter(n=>n>1).slice(0,8);
    if(aiHues.length === 0){
      aiDot.style.background = '#ff6b6b';
    } else {
      const stops = aiHues.map(h => `hsl(${G.playerHue[h]} 70% 55%)`);
      if(stops.length === 1) aiDot.style.background = stops[0];
      else aiDot.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
    }
  }
}
function getPlayerColor(pid, kind){
  // kind: 'fleet'|'system'|'lane'|'minimap'
  if(!pid || pid === 0) return '#b0b8c6';
  if(pid === 1){
    // player colors (blue)
    if(kind==='lane') return 'hsl(206 80% 60% / 0.9)';
    if(kind==='minimap') return '#4ea3ff';
    if(kind==='fleet') return 'hsl(206 85% 60%)'; // slightly brighter/more saturated for fleets
    return '#4ea3ff';
  }
  const hue = G.playerHue[pid] !== undefined ? G.playerHue[pid] : ((pid-2)*137.508)%360;
  // tuning lightness per kind so visuals are pleasant
  let l = 55, a = 1.0, sat=70;
  if(kind === 'system') l = 50;
  if(kind === 'fleet') { l = 60; sat = 82; } // fleets slightly lighter and more saturated
  if(kind === 'lane') { l = 50; a = 0.9; }
  if(kind === 'minimap') { l = 55; a = 1.0; }
  // use modern hsl with optional alpha
  // For fleets, apply a small hue shift so they contrast with systems of the same owner
  if(kind === 'fleet'){
    const fleetHue = (hue + 8) % 360; // small hue offset
    if(a === 1) return `hsl(${fleetHue} ${sat}% ${l}%)`;
    return `hsl(${fleetHue} ${sat}% ${l}% / ${a})`;
  }
  if(a === 1) return `hsl(${hue} ${sat}% ${l}%)`;
  return `hsl(${hue} ${sat}% ${l}% / ${a})`;
}

/* ===== Galaxy Generation ===== */
function generateGalaxy(settings){
  resetGame();
  const seed = settings.seed || (Math.random().toString(36).slice(2));
  G.seed = seed;
  G.rng = seededRNG(seed + '_galaxy'); const rng = G.rng;
  const W = G.width = 3000, H = G.height = 1800;
  const total = Math.max(5, Math.min(1000, settings.systems || 120));
  const sectorsCount = Math.max(3, Math.min(20, Math.round(total / (40 + rng()*20))));
  let sectorCenters = [];
  for(let i=0;i<sectorsCount;i++){
    const cx = 120 + rng()*(W-240); const cy = 120 + rng()*(H-240);
    sectorCenters.push({x:cx,y:cy});
    const hue = Math.floor(rng()*360);
    const color = `hsl(${hue} 70% 45% / 0.12)`;
    const name = makeName(rng,2) + ' Sector';
    G.sectors.push(new Sector(i,color,name));
  }

  // distribute systems among sectors
  let assigned = 0;
  for(let i=0;i<sectorsCount;i++){
    let remaining = total - assigned;
    let remainingSectors = sectorsCount - i;
    let take = Math.max(1, Math.floor(rng()*(remaining/remainingSectors*1.6) + 1));
    if(i===sectorsCount-1) take = remaining;
    assigned += take;
    for(let s=0;s<take;s++){
      const jitter = 400 + rng()*220; const ang = rng()*Math.PI*2;
      const cx = sectorCenters[i].x + Math.cos(ang)*rng()*jitter;
      const cy = sectorCenters[i].y + Math.sin(ang)*rng()*jitter;
      const sys = new SystemNode(G.nextSystemId++, cx, cy, i, makeName(rng,1 + Math.round(rng()*2)));
      // production: normal systems 0.1 - 5.0 (tenths)
      sys.baseProd = randDecimal(rng, 0.1, 5.0);
      sys.defense = randDecimal(rng, 0.1, 2.0);
      G.systems.push(sys);
      G.sectors[i].systems.push(sys);
    }
  }

  // create k-nearest edges
  const k = 3 + Math.floor(rng()*3);
  for(let a of G.systems){
    let dists = G.systems.map(b=>({b, d: dist(a,b)})).filter(o=>o.b!==a).sort((x,y)=>x.d-y.d);
    for(let i=0;i<Math.min(k,dists.length);i++) addEdge(a,dists[i].b);
  }

  ensureConnected(rng);

  // cross-sector lanes sometimes
  for(let i=0;i<G.sectors.length;i++){
    for(let j=i+1;j<G.sectors.length;j++){
      if(rng()<0.25){
        const a = choice(rng, G.sectors[i].systems);
        const b = choice(rng, G.sectors[j].systems);
        addEdge(a,b);
      }
    }
  }

  // sector hulls
  for(let sec of G.sectors){ sec.hull = convexHull(sec.systems.map(s=>({x:s.x,y:s.y}))); }

  // starting positions: pick central system for player
  G.systems.sort((a,b)=>Math.hypot(a.x-W/2,a.y-H/2)-Math.hypot(b.x-W/2,b.y-H/2));
  const playerStart = G.systems[0];
  // make starting system a bit stronger and with production between 0.1 and 10
  playerStart.owner = 1;
  playerStart.defense = Math.max(playerStart.defense, 18);
  playerStart.baseProd = randDecimal(rng, 0.1, 10.0);
  const cityBonus = randDecimal(rng, 0.1, 2.5);
  playerStart.baseProd = Math.round((playerStart.baseProd + cityBonus)*10)/10;

  // record the designated player starting system so other code can refer to it
  G.playerStart = playerStart;

  // players
  G.players[1] = {id:1, name:'Player', credits:100.0, income:0.0, isAI:false, difficulty:1.0};
  const aiCount = Math.max(1, Math.min(100, settings.aiCount || 3));
  // assign AI starts to random neutral systems (avoid player start)
  let availableStarts = G.systems.filter(s => s.owner === 0);
  for(let i=0;i<aiCount;i++){
    const pid = 2 + i;
    G.players[pid] = {id:pid, name:'AI-'+(i+1), credits:300 * settings.difficulty, income:0.0, isAI:true, difficulty: settings.difficulty};
    if(availableStarts.length===0) break;
    const pick = Math.floor(rng()*availableStarts.length);
    const s = availableStarts.splice(pick,1)[0];
    s.owner = pid;
    s.defense = Math.max(s.defense, 12);
    s.baseProd = Math.max(0.1, s.baseProd + randDecimal(rng, 0.1, 5.0));
  }

  recalcIncome();
  G.view.x = W/2; G.view.y = H/2;
  G.view.scale = clamp(lerp(0.6,1.0, 1 - Math.min(1, total/600)), 0.4, 1.2);

  // assign hues / colors for AIs (must be done after G.players exists)
  setPlayerHues();
}

/* edges */
function addEdge(a,b){
  if(!a || !b || a===b) return;
  for(let e of G.edges) if((e.a===a && e.b===b) || (e.a===b && e.b===a)) return;
  G.edges.push({a:a,b:b});
  a.connected.push(b); b.connected.push(a);
}

function ensureConnected(rng){
  if(G.edges.length===0) return;
  const visited = new Set();
  const comps = [];
  for(let s of G.systems){
    if(visited.has(s)) continue;
    const comp = [];
    const stack = [s];
    visited.add(s);
    while(stack.length){
      const cur = stack.pop();
      comp.push(cur);
      for(let n of cur.connected) if(!visited.has(n)){ visited.add(n); stack.push(n); }
    }
    comps.push(comp);
  }
  for(let i=0;i<comps.length-1;i++){
    const a = choice(rng, comps[i]);
    const b = choice(rng, comps[i+1]);
    addEdge(a,b);
  }
}

function recalcIncome(){
  for(let pid in G.players){ G.players[pid].income = 0.0; }
  for(let s of G.systems){
    if(s.owner && G.players[s.owner]){
      let prod = s.baseProd + (s.mines ? s.mineBonus : 0);
      G.players[s.owner].income += prod;
    }
  }
}

/* ===== Game Loop & Logic ===== */
function tick(dt){
  if(!G.running) return;
  G.time += dt;

  // economy (continuous)
  for(let pid in G.players){ const p = G.players[pid]; p.credits += p.income * dt; }

  // process system queues
  for(let s of G.systems){
    if(s.queue.length>0){
      let task = s.queue[0];
      task.timeLeft -= dt;
      if(task.timeLeft <= 0){
        const finished = s.queue.shift();
        applyBuilt(s, finished);
      }
    }
  }

  // fleet movement
  for(let f of G.fleets.slice()){
    if(f.moving && f._from && f._to){
      const from=f._from, to=f._to;
      const edgeLen = dist(from,to);
      if(edgeLen===0) continue;
      // progress is percent 0..100
      f.progress += f.speed * dt * 4 / edgeLen;
      const t = clamp(f.progress/100,0,1);
      f.pos.x = lerp(from.x,to.x,t);
      f.pos.y = lerp(from.y,to.y,t);
      if(f.progress>=100){
        // arrived at 'to'
        f.currentNode = to;
        f.pos.x = to.x; f.pos.y = to.y;
        // resolve combat / conquest on arrival
        const survived = resolveArrival(f);
        if(!survived) continue; // fleet destroyed and removed
        // advance along path if there is another hop
        if(f.path && Array.isArray(f.path)){
          const idx = f.path.findIndex(p => p === f.currentNode);
          if(idx >= 0 && (idx + 1) < f.path.length){
            // continue to next hop
            f.pathIndex = idx;
            f._from = f.path[f.pathIndex];
            f._to = f.path[f.pathIndex + 1];
            f.progress = 0; f.moving = true;
          } else {
            // finished path
            f.moving = false; f._from = null; f._to = null; f.progress = 0;
          }
        } else {
          f.moving = false; f._from = null; f._to = null; f.progress = 0;
        }
      }
    }
  }

  // merge friendly fleets at nodes
  mergeFleetsAtNodes();

  // AI
  aiTick(dt);

  // Auto-capture: for any idle player fleets that have the autoCapture flag, pick next target and send
  for(let f of G.fleets.slice()){
    if(!f || f.owner !== 1) continue;
    if(f.autoCapture && !f.moving){
      const cfg = f.autoCapture;
      const fullPath = findWeakestClosestLine(f.currentNode, f.owner, cfg.includeNeutral, cfg.includeAI);
      if(fullPath && fullPath.length > 1){
        const built = buildAutoCapturePath(fullPath, f.strength, f.owner, cfg.stopIfSuicidal);
        if(built && built.length > 1){ sendFleetAlong(f, built); }
        else {
          // nothing to do; clear autoCapture if it can't proceed further
          // keep it set so player can resume later manually
        }
      }
    }
  }

  // recalc & UI
  recalcIncome();
  updateSelectionUI();
  draw();
  checkWinConditions();
}

/* When a queued task finishes, apply its effect */
function applyBuilt(system, task){
  if(task.type==='mine'){
    // up to 3 mines
    system.mines = (system.mines || 0) + 1;
    const bonus = randDecimal(G.rng, 0.1, 1.0); // mine per-spec
    system.mineBonus = (system.mineBonus || 0) + bonus;
    system.defense = (system.defense || 0) + 3; // mine adds 3 defense
  }
  else if(task.type==='shipyard'){
    system.buildings.shipyard = true;
    system.defense = (system.defense || 0) + 7; // shipyard adds 7 defense
  }
  else if(task.type==='outpost'){
    if(system.buildings.outposts === undefined) system.buildings.outposts = 0;
    system.buildings.outposts++;
    system.defense = (system.defense || 0) + 10;
  }
  else if(task.type==='fleet'){
    const fleet = new Fleet(G.nextFleetId++, task.owner, task.strength || 1, system);
    G.fleets.push(fleet);
  }
}

/* Resolve arrival: handle fleet vs fleet and system conquest */
function resolveArrival(f){
  const node = f.currentNode;
  if(!node) return true;

  // find other non-moving fleets at this node
  const presentFleets = G.fleets.filter(ff => ff.currentNode === node && !ff.moving);
  // If there are enemy fleets (other owners) present, do fleet-vs-fleet combat
  const ownersPresent = new Set(presentFleets.map(ff => ff.owner));
  // include arriving fleet (it may already exist in the list)
  ownersPresent.add(f.owner);

  const otherOwners = Array.from(ownersPresent).filter(o => o !== f.owner);
  if(presentFleets.some(ff => ff.owner !== f.owner)){
    // group strengths per owner
    const groups = new Map();
    // sum existing non-moving fleets
    for(const ff of presentFleets){
      groups.set(ff.owner, (groups.get(ff.owner) || 0) + ff.strength);
    }
    // include the just-arrived fleet (it might already be counted if presentFleets included it)
    groups.set(f.owner, (groups.get(f.owner) || 0) + f.strength);

    // add system defense to the group that is friendly to the system (if any), but track it separately so it is NOT converted to fleet strength
    let defenseAddedTo = null;
    if(node.defense && node.owner && groups.has(node.owner)) {
      groups.set(node.owner, groups.get(node.owner) + node.defense);
      defenseAddedTo = node.owner;
    }

    // pick winner and compute remaining power
    let winner = null, winnerStrength = -Infinity;
    for(const [owner, val] of groups.entries()){
      if(val > winnerStrength){ winner = owner; winnerStrength = val; }
    }
    // Calculate mutual losses: each side loses the total strength of the other sides
    // 1. Find the two strongest sides (if more than 2, all vs all)
    let maxStrength = -Infinity, secondStrength = -Infinity;
    let maxOwner = null, secondOwner = null;
    for(const [owner, val] of groups.entries()) {
      if(val > maxStrength) {
        secondStrength = maxStrength;
        secondOwner = maxOwner;
        maxStrength = val;
        maxOwner = owner;
      } else if(val > secondStrength) {
        secondStrength = val;
        secondOwner = owner;
      }
    }
    // If more than 2 sides, all lose the sum of the others
    let survivors = [];
    for(const [owner, val] of groups.entries()) {
      let others = 0;
      for(const [other, oval] of groups.entries()) if(other !== owner) others += oval;
      const left = val - others;
      if(left > 0) survivors.push({owner, strength: left});
    }
    // Remove all fleets at the node
    for(let ff of G.fleets.slice()){
      if(ff.currentNode === node) removeFleet(ff);
    }
    if(survivors.length === 1) {
      // One side remains
      const s = survivors[0];
      // If the winner was the system owner and defense was added, subtract defense from the leftover strength (it was not fleet strength)
      let leftover = s.strength;
      if(defenseAddedTo !== null && s.owner === defenseAddedTo) {
        leftover -= node.defense;
      }
      const newStrength = Math.max(1, Math.round(leftover));
      const newFleet = new Fleet(G.nextFleetId++, s.owner, newStrength, node);
      // If the arriving fleet had an intended path, transfer it to the new fleet so it continues
      try{
        if(f && f.path){
          newFleet.path = f.path;
          // After arrival at 'node', find index of this node in the path
          const idx = newFleet.path.findIndex(p=>p === node);
          if(idx >= 0){
            newFleet.pathIndex = idx;
            // if there is a next hop, set movement
            if((newFleet.pathIndex + 1) < newFleet.path.length){
              newFleet._from = newFleet.path[newFleet.pathIndex];
              newFleet._to = newFleet.path[newFleet.pathIndex+1];
              newFleet.moving = true;
              newFleet.progress = 0;
            } else {
              newFleet._from = null; newFleet._to = null; newFleet.moving = false; newFleet.progress = 0;
            }
          } else {
            // fallback: carry over previous movement fields
            newFleet.pathIndex = f.pathIndex || 0;
            newFleet._from = f._from; newFleet._to = f._to; newFleet.moving = f.moving; newFleet.progress = f.progress || 0;
          }
          // carry over persistent flags like autoCapture
          if(f.autoCapture) newFleet.autoCapture = Object.assign({}, f.autoCapture);
        }
      } catch(e){ /* ignore transfer errors */ }
      G.fleets.push(newFleet);
      // If the winner isn't the system owner, attempt to capture the system using remaining strength vs system defense
      if(node.owner !== s.owner){
        if(newFleet.strength > node.defense){
          // capture: subtract defense from fleet
          newFleet.strength = Math.max(1, newFleet.strength - node.defense);
          node.owner = s.owner;
          node.defense = 0;
        } else {
          // fleet fails to capture; reduce defense and remove fleet
          node.defense = Math.max(0, node.defense - newFleet.strength);
          removeFleet(newFleet);
          recalcIncome();
          return false;
        }
      }
      recalcIncome();
      return true;
    } else {
      // everyone destroyed or perfectly canceled out
      recalcIncome();
      return false;
    }
  }

  // no enemy fleets present: standard conquest vs system defense
  if(node.owner === f.owner){
    // friendly — just settle
    f.moving = false; f._from = null; f._to = null; f.progress = 0;
    f.pos.x = node.x; f.pos.y = node.y; f.currentNode = node;
    return true;
  }

  // hostile or neutral system without fleets
  if(f.strength > node.defense){
    const leftover = f.strength - node.defense;
    node.owner = f.owner;
    node.defense = 0;
    f.strength = Math.max(1, Math.round(leftover));
    recalcIncome();
    return true;
  } else if(f.strength === node.defense){
    node.defense = 0;
    removeFleet(f);
    return false;
  } else {
    node.defense = Math.max(0, node.defense - Math.round(f.strength));
    removeFleet(f);
    return false;
  }
}

function mergeFleetsAtNodes(){
  const map = new Map();
  for(let f of G.fleets){
    if(!f.moving){
      if(!f.currentNode) continue;
      const key = f.currentNode.id + '-' + f.owner;
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push(f);
    }
  }
  for(let [k, arr] of map){
    if(arr.length>1){
      const base = arr[0];
      for(let i=1;i<arr.length;i++){ base.strength += arr[i].strength; removeFleet(arr[i]); }
    }
  }
}

function removeFleet(f){
  const idx = G.fleets.indexOf(f);
  if(idx>=0) G.fleets.splice(idx,1);
}

/* ===== AI ===== */
function aiTick(dt){
  // Simplified AI to reduce CPU cost:
  // - Lower think frequency (per-AI timer)
  // - Only look one hop out for movement targets (no deep BFS)
  // - Minimal build decisions, fewer array scans
  if(!G._aiTimers) G._aiTimers = {};
  for(let pid in G.players){
    const p = G.players[pid];
    if(!p.isAI) continue;
    if(!G._aiTimers[pid]) G._aiTimers[pid] = 0;
    G._aiTimers[pid] += dt;
    // Think rarely: base 1.2s, faster at higher difficulty but clamped
    const think = clamp(1.2 / (p.difficulty || 1.0), 0.4, 4.0);
    if(G._aiTimers[pid] < think) continue;
    G._aiTimers[pid] = 0;

    // Minimal caches to avoid repeated filters
    const mySystems = [];
    const myFleets = [];
    for(const s of G.systems){ if(s.owner == pid) mySystems.push(s); }
    for(const f of G.fleets){ if(f.owner == pid) myFleets.push(f); }

    // Simple building logic: if credit threshold met, build one fleet or mine occasionally
    if(p.credits >= 150 && mySystems.length > 0 && G.rng() < 0.25){
      // pick a random shipyard-capable system (prefer existing shipyard)
      let yard = mySystems.find(s=>s.buildings.shipyard);
      if(!yard) yard = mySystems[Math.floor(G.rng()*mySystems.length)];
      if(yard){ p.credits -= 150; yard.queue.push({type:'fleet', timeLeft:12, total:12, owner:pid, strength: Math.max(1, Math.round(G.rng()*2 + (p.difficulty||1)))}); }
    }
    if(p.credits >= 100 && mySystems.length > 0 && G.rng() < 0.18){
      const s = mySystems[Math.floor(G.rng()*mySystems.length)];
      const built = s.mines || 0; const queued = s.queue ? s.queue.filter(q=>q.type==='mine').length : 0;
      if(built + queued < 3){ p.credits -= 100; s.queue.push({type:'mine', timeLeft:45, total:45, owner:pid}); }
    }

    // Movement: for each idle fleet, look at adjacent nodes only and attack the weakest allowable neighbor.
    for(const f of myFleets){
      if(!f || f.moving || !f.currentNode) continue;
      // look at adjacent neighbors only (cheap)
      let best = null; let bestScore = Infinity;
      for(const nb of f.currentNode.connected){
        if(!nb) continue;
        if(nb.owner == pid) continue; // skip owned
        // respect simple target flags: attack neutrals and players/AIs
        // score: defense + distance small weight
        const score = nb.defense + 0.001 * dist(f.currentNode, nb);
        if(score < bestScore){ bestScore = score; best = nb; }
      }
      if(best){
        // only attack if a reasonable chance (fleet strength > defense * factor depending on difficulty)
        const required = Math.max(1, Math.round(best.defense * (0.9 + 0.25*(1/p.difficulty))));
        if(f.strength > required || G.rng() < 0.06){
          // send to neighbor directly
          const path = [f.currentNode, best];
          sendFleetAlong(f, path);
        }
      }
    }
  }
}

function findNearestTarget(node, owner){
  let best=null, bd=Infinity;
  for(let s of G.systems){ if(s.owner==owner) continue; const d = dist(node,s); if(d < bd){ bd=d; best=s; } }
  return best;
}

/* ===== UI & Interaction ===== */
function setupUI(){
  const canvas = document.getElementById('gameCanvas');
  G.canvas = canvas; G.ctx = canvas.getContext('2d');
  const minimap = document.getElementById('minimap'); G.minimapCtx = minimap.getContext('2d');

  // add a diagnostic click listener to the buildQueue container so clicks are visible in the console
  try{
    const buildQueueEl = document.getElementById('buildQueue');
    if(buildQueueEl && !buildQueueEl._hasListener){
      buildQueueEl.addEventListener('click', (e)=>{ console.debug('buildQueue clicked target:', e.target, 'nodeName:', e.target && e.target.nodeName); }, true);
      buildQueueEl._hasListener = true;
    }
  } catch(e){ /* ignore */ }

  function resize(){
    canvas.width = Math.max(600, window.innerWidth - (document.getElementById('leftPane') ? document.getElementById('leftPane').offsetWidth + 40 : 40));
    canvas.height = Math.max(400, window.innerHeight - 30);
    draw();
  }
  window.addEventListener('resize', resize);
  resize();

  // Global debug: log pointerdown events to help diagnose UI click issues
  if(!window._pointerDebugAdded){
    window.addEventListener('pointerdown', (e)=>{ try{ console.debug('global pointerdown', {target: e.target && (e.target.id || e.target.className || e.target.nodeName), x: e.clientX, y: e.clientY}); } catch(_){} }, true);
    window._pointerDebugAdded = true;
  }

  // menu UI wiring
  const sysRange = document.getElementById('systemsRange'); const sysCount = document.getElementById('sysCount');
  sysRange.addEventListener('input', ()=> sysCount.textContent = sysRange.value);

  const aiRange = document.getElementById('aiCount'); const aiLabel = document.getElementById('aiCountLabel');
  aiRange.addEventListener('input', ()=> aiLabel.textContent = aiRange.value);

  document.getElementById('launchBtn').addEventListener('click', ()=>{ 
    const diff = parseFloat(document.getElementById('difficulty').value);
    const systems = parseInt(document.getElementById('systemsRange').value,10);
    const seed = document.getElementById('seed').value.trim() || null;
    const aiCount = parseInt(document.getElementById('aiCount').value,10);
    startGame({systems:systems, difficulty:diff, aiCount:aiCount, seed:seed});
  });

  // Spectate AI-only game: launches with the human player as neutral/spectator
  const spectateBtn = document.getElementById('spectateBtn');
  if(spectateBtn){
    spectateBtn.addEventListener('click', ()=>{
      const diff = parseFloat(document.getElementById('difficulty').value);
      const systems = parseInt(document.getElementById('systemsRange').value,10);
      const seed = document.getElementById('seed').value.trim() || null;
      const aiCount = parseInt(document.getElementById('aiCount').value,10);
      startSpectate({systems:systems, difficulty:diff, aiCount:aiCount, seed:seed});
    });
  }

  document.getElementById('loadExample').addEventListener('click', ()=>{
    document.getElementById('systemsRange').value=160; document.getElementById('sysCount').textContent=160;
    document.getElementById('difficulty').value=1.0; document.getElementById('aiCount').value=4; document.getElementById('aiCountLabel').textContent=4;
    document.getElementById('seed').value='example-42';
  });

  document.getElementById('toMenu').addEventListener('click', ()=> stopGame());
  document.getElementById('buildMine').addEventListener('click', ()=> buildBuildingCommand('mine'));
  document.getElementById('buildShipyard').addEventListener('click', ()=> buildBuildingCommand('shipyard'));
  document.getElementById('buildOutpost').addEventListener('click', ()=> buildBuildingCommand('outpost'));
  document.getElementById('buildFleet').addEventListener('click', ()=> buildFleetCommand());
  document.getElementById('sendFleet').addEventListener('click', ()=>{ if(G.selectedFleets.length>0){ G.sendMode = true; document.getElementById('sendFleet').textContent = 'Click destination'; } else alert('Select some fleets by dragging a box over them first.'); });
  document.getElementById('autoCapture').addEventListener('click', ()=>{
    if(G.selectedFleets.length===0){ alert('Select some fleets by dragging a box over them first.'); return; }
    const includeNeutral = document.getElementById('acIncludeNeutral').checked;
    const includeAI = document.getElementById('acIncludeAI').checked;
    // mark selected fleets as auto-capture and send an initial path
    autoCaptureSelectedFleets(includeNeutral, includeAI);
  });

  document.getElementById('stopAutoCapture').addEventListener('click', ()=>{
    if(G.selectedFleets.length===0){ alert('Select some fleets by dragging a box over them first.'); return; }
    stopAutoCaptureSelectedFleets();
  });

  document.getElementById('zoomSlider').addEventListener('input', (e)=>{ G.view.scale = parseFloat(e.target.value); draw(); });

  // Dev console wiring
  const devRun = document.getElementById('devConsoleRun');
  const devClear = document.getElementById('devConsoleClear');
  const devExample = document.getElementById('devConsoleFillExample');
  const devInput = document.getElementById('devConsoleInput');
  const devOut = document.getElementById('devConsoleOutput');
  function devLog(msg){ devOut.textContent = (devOut.textContent ? devOut.textContent + '\n' : '') + msg; devOut.scrollTop = devOut.scrollHeight; }
  devRun.addEventListener('click', ()=>{ const cmd = devInput.value.trim(); if(!cmd) return; try{ const res = runDevCommand(cmd); devLog('> ' + cmd); devLog(String(res)); } catch(e){ devLog('Error: ' + e.message); } devInput.value=''; });
  devClear.addEventListener('click', ()=>{ devOut.textContent=''; });
  devExample.addEventListener('click', ()=>{ devInput.value = 'credits 1000\nspawn 5 1 3\nspawn 8 2 4\nlist systems'; });

  // UI toggle wiring
  const uiBtn = document.getElementById('uiToggleBtn');
  const uiPanel = document.getElementById('uiTogglePanel');
  const chkLeft = document.getElementById('toggleLeftPane');
  const chkDev = document.getElementById('toggleDevConsole');
  const chkHUD = document.getElementById('toggleHUD');
  const chkFooter = document.getElementById('toggleFooter');

  function applyToggles(){
    document.getElementById('leftPane').style.display = chkLeft.checked ? 'block' : 'none';
    document.getElementById('devConsolePanel').style.display = chkDev.checked ? 'block' : 'none';
    document.getElementById('hud').style.display = chkHUD.checked ? (G.running ? 'block':'none') : 'none';
    document.getElementById('footer').style.display = chkFooter.checked ? (G.running ? 'block' : 'none') : 'none';
    // resize canvas in case layout changed (small timeout so DOM recomputes)
    setTimeout(()=>{ try{ resize(); }catch(e){ if(G.canvas) draw(); } }, 80);
  }
  uiBtn.addEventListener('click', ()=>{ uiPanel.style.display = uiPanel.style.display === 'none' ? 'block' : 'none'; setTimeout(()=>{ try{ resize(); }catch(e){ if(G.canvas) draw(); } }, 40); });
  chkLeft.addEventListener('change', applyToggles);
  chkDev.addEventListener('change', applyToggles);
  chkHUD.addEventListener('change', applyToggles);
  chkFooter.addEventListener('change', applyToggles);

  window.addEventListener('keydown', (e)=>{
    if(e.key === 'u' || e.key === 'U'){
      uiPanel.style.display = uiPanel.style.display === 'none' ? 'block' : 'none';
      e.preventDefault();
    }
  });

  // canvas interactions (pan/right-drag, left drag selection)
  let isRightDown=false, lastX=0,lastY=0; let isLeftDown=false;
  canvas.addEventListener('mousedown', (ev)=>{
    const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    const pos = screenToWorld(sx,sy);
    if(ev.button===2){ isRightDown=true; lastX=ev.clientX; lastY=ev.clientY; }
    else if(ev.button===0){ isLeftDown=true; G._selStart = {sx,sy, wx:pos.x, wy:pos.y}; G._selRect = null; draw(); }
  });

  canvas.addEventListener('mousemove', (ev)=>{
    const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    const pos = screenToWorld(sx,sy);
    if(isRightDown){
      const dx=(lastX-ev.clientX)/G.view.scale; const dy=(lastY-ev.clientY)/G.view.scale;
      G.view.x += dx; G.view.y += dy; lastX=ev.clientX; lastY=ev.clientY; draw();
    }
    if(isLeftDown && G._selStart){
      G._selRect = {x0:G._selStart.sx, y0:G._selStart.sy, x1:sx, y1:sy};
      draw();
    }
    detectHover(sx,sy);
  });

  window.addEventListener('mouseup', (ev)=>{
    if(ev.button===2) isRightDown=false;
    if(ev.button===0){
      if(G._selRect){
        finalizeSelectionRect(G._selRect);
        G._selRect=null; G._selStart=null; draw();
        G._suppressClick = performance.now(); // prevent the click event immediately after a drag
      }
      isLeftDown=false;
    }
  });

  window.addEventListener('contextmenu', (e)=> e.preventDefault());

  canvas.addEventListener('wheel', (ev)=>{
    ev.preventDefault();
    const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    const before = screenToWorld(sx,sy);
    const delta = -ev.deltaY * 0.0015;
    G.view.scale = clamp(G.view.scale * (1 + delta), 0.25, 2.5);
    document.getElementById('zoomSlider').value = G.view.scale;
    const after = screenToWorld(sx,sy);
    G.view.x += before.x - after.x; G.view.y += before.y - after.y;
    draw();
  }, {passive:false});

  // click handling: either send mode or select system
  canvas.addEventListener('click', (ev)=>{
    // prevent a click immediately after a drag-selection
    if(performance.now() - (G._suppressClick || 0) < 200) return;

    const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    const pos = screenToWorld(sx,sy);

    if(G.sendMode){
      let nearest=null, nd=Infinity;
      for(let s of G.systems){ const d = Math.hypot(s.x-pos.x, s.y-pos.y); if(d<nd){ nd=d; nearest=s; } }
      if(nearest && nd < 18 / G.view.scale){
        for(let f of G.selectedFleets.slice()){
          const path = findPath(f.currentNode, nearest);
          if(path.length>1) sendFleetAlong(f, path);
        }
        G.sendMode=false; document.getElementById('sendFleet').textContent='Send Fleet';
        G.selectedFleets=[];
        updateSelectionUI(); draw();
      } else {
        alert('No valid destination selected. Click near a system.');
      }
      return;
    }

    // First, check if the player clicked near a fleet (moving or idle). Prefer selecting fleets over systems.
    let nearestFleet = null, fd = Infinity;
    for(let f of G.fleets){ if(f.owner !== 1) continue; const d = Math.hypot(f.pos.x - pos.x, f.pos.y - pos.y); if(d < fd){ fd = d; nearestFleet = f; } }
    const fleetClickThreshold = 14 / G.view.scale;
    if(nearestFleet && fd < fleetClickThreshold){
      // select the fleet (single selection)
      G.selectedFleets = [nearestFleet]; G.selectedSystem = null; updateSelectionUI(); draw();
      return;
    }

    // otherwise select a system
    let nearest=null, nd=Infinity;
    for(let s of G.systems){ const d = Math.hypot(s.x-pos.x, s.y-pos.y); if(d<nd){ nd=d; nearest=s; } }
    if(nearest && nd < 18 / G.view.scale){ G.selectedSystem = nearest; G.selectedFleets=[]; updateSelectionUI(); draw(); }
    else { G.selectedSystem = null; updateSelectionUI(); draw(); }
  });
}

/* coordinate transforms */
function screenToWorld(sx,sy){
  const originX = G.view.x - (G.canvas.width / 2) / G.view.scale;
  const originY = G.view.y - (G.canvas.height / 2) / G.view.scale;
  const x = sx / G.view.scale + originX;
  const y = sy / G.view.scale + originY;
  return {x,y};
}
function worldToScreen(wx,wy){
  const originX = G.view.x - (G.canvas.width / 2) / G.view.scale;
  const originY = G.view.y - (G.canvas.height / 2) / G.view.scale;
  const sx = ((wx - originX)) * G.view.scale;
  const sy = ((wy - originY)) * G.view.scale;
  return {x:sx,y:sy};
}

/* hover detection */
function detectHover(sx,sy){
  const pos = screenToWorld(sx,sy);
  G.hoverEdge = null; G.hoverNode = null;
  let best = Infinity;
  for(let e of G.edges){
    const d = pointLineDist(pos.x,pos.y, e.a.x,e.a.y, e.b.x,e.b.y);
    if(d < best){ best = d; G.hoverEdge = e; }
  }
  if(best > 30 / G.view.scale) G.hoverEdge = null;
  for(let s of G.systems){
    const d = Math.hypot(s.x-pos.x, s.y-pos.y);
    if(d < 12 / G.view.scale){ G.hoverNode = s; break; }
  }
}

/* selection finalize */
function finalizeSelectionRect(rect){
  const x0 = Math.min(rect.x0, rect.x1), x1 = Math.max(rect.x0, rect.x1), y0 = Math.min(rect.y0, rect.y1), y1 = Math.max(rect.y0, rect.y1);
  const p0 = screenToWorld(x0,y0), p1 = screenToWorld(x1,y1);
  const wx0 = Math.min(p0.x,p1.x), wx1 = Math.max(p0.x,p1.x), wy0 = Math.min(p0.y,p1.y), wy1 = Math.max(p0.y,p1.y);
  G.selectedFleets = [];
  // include both idle and moving player fleets so the user can select fleets in transit
  for(let f of G.fleets){
    if(f.owner===1){
      if(f.pos.x >= wx0 && f.pos.x <= wx1 && f.pos.y >= wy0 && f.pos.y <= wy1) G.selectedFleets.push(f);
    }
  }
  updateSelectionUI();
}

/* UI updates */
function updateSelectionUI(){
  if(G.players[1]){
    document.getElementById('credits').textContent = G.players[1].credits.toFixed(1);
    document.getElementById('income').textContent = G.players[1].income.toFixed(1);
  } else {
    document.getElementById('credits').textContent = '0.0';
    document.getElementById('income').textContent = '0.0';
  }
  document.getElementById('timeLabel').textContent = Math.floor(G.time) + 's';
  const sel = G.selectedSystem;
  if(sel){
    document.getElementById('selectedName').textContent = sel.name;
    document.getElementById('selectedOwner').textContent = 'Owner: ' + (sel.owner? (G.players[sel.owner] ? G.players[sel.owner].name : 'Unknown') : 'Neutral');
    const prodText = (sel.baseProd + (sel.mines? sel.mineBonus:0)).toFixed(1);
    document.getElementById('selectedIncome').textContent = 'Prod: ' + prodText + ', Defense: ' + sel.defense + ', Mines: ' + (sel.mines||0) + (sel.buildings.shipyard? ', Shipyard':'');

    const q = document.getElementById('buildQueue'); q.innerHTML = '';
    sel.queue.forEach((t,i)=>{
      const el = document.createElement('div'); el.style.marginTop = '6px';
      const pct = t.total ? Math.max(0, Math.min(100, ((t.total - t.timeLeft) / t.total * 100))) : 0;

      // top row: label and time
      const row = document.createElement('div'); row.style.fontSize = '12px';
      const label = document.createElement('span'); label.textContent = `${i+1}. ${t.type}`;
      row.appendChild(label);
      const timeSpan = document.createElement('span'); timeSpan.style.cssText = 'float:right'; timeSpan.textContent = `${(t.timeLeft||0).toFixed(1)}s`;
      row.appendChild(timeSpan);

      // Cancel button (only for player's queued tasks)
      if(sel.owner === 1 && t.owner === 1){
        const btn = document.createElement('button');
        btn.dataset.idx = String(i);
        btn.style.marginLeft = '8px'; btn.style.padding = '4px'; btn.style.borderRadius = '6px'; btn.style.fontSize = '11px';
        if(i === 0){
          btn.title = 'Stop and cancel current build'; btn.style.background = 'transparent'; btn.style.border = 'none'; btn.style.color = '#ff6b6b'; btn.style.fontWeight = '700'; btn.textContent = '✕';
        } else {
          btn.textContent = 'Cancel';
        }
        // ensure button does not cause parent click handlers and attach listener
  // ensure clickable and accessible
  btn.type = 'button'; btn.style.cursor = 'pointer'; btn.setAttribute('aria-label', 'Cancel queued build');
  // primary handler on pointerdown to avoid potential click suppression by other handlers
  btn.addEventListener('pointerdown', (ev) => { ev.stopPropagation(); ev.preventDefault(); console.debug('pointerdown on cancel button', {systemId: sel && sel.id, idx: i}); cancelQueuedTask(sel, i); });
  // also keep click for compatibility
  btn.addEventListener('click', (ev) => { ev.stopPropagation(); ev.preventDefault(); console.debug('click on cancel button', {systemId: sel && sel.id, idx: i}); cancelQueuedTask(sel, i); });
        // put button to the right of the time span by appending after it
        row.appendChild(btn);
      }

      el.appendChild(row);

      // progress bar
      const barWrap = document.createElement('div'); barWrap.className = 'progressBar';
      const fill = document.createElement('div'); fill.className = 'progressFill'; fill.style.width = pct + '%';
      barWrap.appendChild(fill);
      el.appendChild(barWrap);

      q.appendChild(el);
    });
  } else {
    document.getElementById('selectedName').textContent = 'None';
    document.getElementById('selectedOwner').textContent = '';
    document.getElementById('selectedIncome').textContent = '';
    document.getElementById('buildQueue').innerHTML = '';
  }
  document.getElementById('selFleetCount').textContent = G.selectedFleets.length;
}

/* build commands */
function buildBuildingCommand(type){
  const s = G.selectedSystem;
  if(!s){ alert('Select a system'); return; }
  if(s.owner !== 1){ alert('You must control the system to build here'); return; }
  const countInput = document.getElementById('buildCount');
  const count = countInput ? Math.max(1, Math.floor(Number(countInput.value) || 1)) : 1;
  const costPer = (type==='mine'?100 : type==='shipyard'?300 : 2500);
  const totalCost = costPer * count;
  if(G.players[1].credits < totalCost){ alert('Not enough credits for ' + count + ' ' + type + (count>1? 's':'')); return; }
  if(type==='mine') {
    // Count built and queued mines
    const built = s.mines || 0;
    const queued = s.queue.filter(q => q.type === 'mine').length;
    if (built + queued + count > 3) { alert('Too many mines requested; max per system is 3 including queued.'); return; }
  }
  if(type==='shipyard' && s.buildings.shipyard){ alert('Shipyard already present'); return; }
  if(type==='outpost') {
    // Count built and queued outposts
    const built = s.buildings.outposts || 0;
    const queued = s.queue.filter(q => q.type === 'outpost').length;
    if (built + queued + count > 2) { alert('Too many outposts requested; max per system is 2 including queued.'); return; }
  }
  // Enforce one shipyard total: do not allow queuing more than one shipyard if one is built or already queued
  if(type === 'shipyard'){
    const hasBuilt = !!s.buildings.shipyard;
    const queuedShipyards = s.queue.filter(q => q.type === 'shipyard').length;
    if(hasBuilt || queuedShipyards > 0){ alert('A shipyard is already present or queued at this system. Only one allowed.'); return; }
  }

  G.players[1].credits -= totalCost;
  // queue the requested number of tasks (each with the same timeLeft)
  for(let i=0;i<count;i++){
    s.queue.push({type:type, timeLeft:45, total:45, owner:1});
  }
  updateSelectionUI();
}
function buildFleetCommand(){
  const s = G.selectedSystem;
  if(!s || s.owner !== 1){ alert('Select a system you control'); return; }
  if(!s.buildings.shipyard){ alert('You need a shipyard here to build fleets'); return; }
  const countInput = document.getElementById('buildCount');
  const count = countInput ? Math.max(1, Math.floor(Number(countInput.value) || 1)) : 1;
  const costPer = 150;
  const totalCost = costPer * count;
  if(G.players[1].credits < totalCost){ alert('Not enough credits to build ' + count + ' fleet(s)'); return; }
  G.players[1].credits -= totalCost;
  for(let i=0;i<count;i++){
    s.queue.push({type:'fleet', timeLeft:12, total:12, owner:1, strength:1});
  }
  updateSelectionUI();
}

/* Cancel a queued task at a system for the player
   - index: position in the system.queue array
   Refund policy:
   - If task hasn't started yet (i > 0), refund full cost
   - If it's the currently-building task (index === 0), refund remaining time proportionally
   Costs are inferred from type (same as build functions)
*/
function cancelQueuedTask(system, index){
  console.debug('cancelQueuedTask called', {systemId: system && system.id, index});
  if(!system || !system.queue || index < 0 || index >= system.queue.length) return;
  const task = system.queue[index];
  if(!task) return;
  if(!G.players[1]) return;
  // remove the queued item
  system.queue.splice(index, 1);
  // remove the queued item; no refund is given to the player by design
  // debug log the cancellation
  console.debug('cancelQueuedTask: cancelled item', {systemId: system && system.id, index, newQueueLen: system.queue.length});

  updateSelectionUI(); draw();
}

/* Pathfinding BFS */
function findPath(a,b){
  if(a===b) return [a];
  const q=[a];
  const prev=new Map();
  prev.set(a,null);
  while(q.length){
    const cur=q.shift();
    for(let n of cur.connected){
      if(prev.has(n)) continue;
      prev.set(n,cur);
      if(n===b){
        const path=[n];
        let p=cur;
        while(p){ path.unshift(p); p=prev.get(p); }
        return path;
      }
      q.push(n);
    }
  }
  return [];
}

/* send fleet */
function sendFleetAlong(f, path){
  if(!path || path.length<2) return;
  f.path = path;
  if(f.currentNode !== path[0]){ f.currentNode = path[0]; f.pos.x = path[0].x; f.pos.y = path[0].y; }
  f.pathIndex = 0;
  f._from = path[0];
  f._to = path[1];
  f.moving = true;
  f.progress = 0;
}

/* ===== Auto Capture Feature =====
   For each selected fleet, find the closest 'line' (sequence) of nearby enemy/neutral systems
   ranked by low defense and proximity. Follow that line until the next hop would destroy the fleet.
   The algorithm: greedily extend path choosing the weakest adjacent unowned system until
   the next system's defense >= fleet.strength (i.e., would destroy if attacked next).
*/
function autoCaptureSelectedFleets(includeNeutral = true, includeAI = true){
  const stopIfSuicidal = document.getElementById('acStopIfSuicidal') ? document.getElementById('acStopIfSuicidal').checked : true;
  for(let f of G.selectedFleets.slice()){
    if(!f) continue;
    // set a persistent autoCapture flag on the fleet so it will continue after each capture
    f.autoCapture = { includeNeutral: !!includeNeutral, includeAI: !!includeAI, stopIfSuicidal: !!stopIfSuicidal };
    // if fleet is idle, send an initial path
    if(f.moving) continue;
    const fullPath = findWeakestClosestLine(f.currentNode, f.owner, includeNeutral, includeAI);
    if(!fullPath || fullPath.length <= 1) continue;
    // build a path applying suicidal rules
    const built = buildAutoCapturePath(fullPath, f.strength, f.owner, stopIfSuicidal);
    if(built && built.length > 1){ sendFleetAlong(f, built); }
  }
  updateSelectionUI(); draw();
}

function stopAutoCaptureSelectedFleets(){
  for(let f of G.selectedFleets.slice()){
    if(f && f.autoCapture) delete f.autoCapture;
  }
  updateSelectionUI(); draw();
}

function buildAutoCapturePath(path, startStrength, owner, stopIfSuicidal){
  // path: array of nodes starting with current node; startStrength is the fleet's strength.
  let simulated = startStrength;
  const res = [path[0]];
  for(let i=1;i<path.length;i++){
    const n = path[i];
    if(n.owner === owner){
      // friendly node — just traverse
      res.push(n); continue;
    }
    // enemy or neutral
    if(simulated > n.defense){
      // can capture and proceed
      simulated = Math.max(1, Math.round(simulated - n.defense));
      res.push(n);
      continue;
    } else {
      // would be destroyed
      if(stopIfSuicidal) break;
      else {
        // allow suicidal attack: include this node and stop after it (fleet will be removed)
        res.push(n);
        break;
      }
    }
  }
  return res;
}

function findWeakestClosestLine(startNode, owner, includeNeutral = true, includeAI = true){
  // Lightweight helper: Instead of deep BFS, just return a two-node path [startNode, bestNeighbor]
  // where bestNeighbor is the adjacent node with lowest defense that matches include flags.
  let best = null; let bestScore = Infinity;
  for(const nb of startNode.connected){
    if(!nb) continue;
    if(nb.owner === owner) continue;
    if(nb.owner === 0 && !includeNeutral) continue;
    if(nb.owner > 1 && !includeAI) continue;
    const score = nb.defense + 0.001 * dist(startNode, nb);
    if(score < bestScore){ bestScore = score; best = nb; }
  }
  if(!best) return null;
  return [startNode, best];
}

/* ===== Dev Console Commands ===== */
function runDevCommand(raw){
  // Accept multiple commands separated by newline
  const lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  let out = [];
  for(const line of lines){
    const parts = line.split(/\s+/);
    const cmd = parts[0].toLowerCase();
    try{
      if(cmd === 'credits'){ const amt = Number(parts[1]||0); if(!G.players[1]) throw new Error('Player not initialized'); G.players[1].credits = amt; out.push('Player credits set to ' + amt); }
      else if(cmd === 'income'){ const amt = Number(parts[1]||0); if(!G.players[1]) throw new Error('Player not initialized'); G.players[1].income = amt; out.push('Player income set to ' + amt); }
      else if(cmd === 'spawn'){ // spawn <systemId> <owner> <strength>
        const sid = Number(parts[1]); const owner = Number(parts[2]||1); const strength = Number(parts[3]||1);
        const sys = G.systems.find(s=>s.id===sid) || G.systems[Math.floor(Math.random()*G.systems.length)];
        if(!sys) throw new Error('No systems available');
        const f = new Fleet(G.nextFleetId++, owner, Math.max(1, Math.round(strength)), sys);
        G.fleets.push(f);
        out.push('Spawned fleet id=' + f.id + ' owner=' + owner + ' strength=' + f.strength + ' at system ' + sys.id);
      }
      else if(cmd === 'list'){ const sub = parts[1] ? parts[1].toLowerCase() : 'systems'; if(sub === 'systems'){ out.push('Systems:'); for(const s of G.systems.slice(0,100)){ out.push(`id=${s.id} owner=${s.owner} def=${s.defense} prod=${s.baseProd.toFixed(1)}`); } } else if(sub === 'fleets'){ out.push('Fleets:'); for(const f of G.fleets){ out.push(`id=${f.id} owner=${f.owner} str=${f.strength} node=${f.currentNode?f.currentNode.id:'-'} moving=${f.moving}`); } } else out.push('Unknown list target'); }
      else if(cmd === 'setowner'){ const sid = Number(parts[1]); const owner = Number(parts[2]||0); const s = G.systems.find(x=>x.id===sid); if(!s) throw new Error('system not found'); s.owner = owner; out.push('system '+sid+' owner set to '+owner); }
      else if(cmd === 'clearfleets'){ G.fleets=[]; out.push('All fleets removed'); }
      else if(cmd === 'tick'){ const t = Number(parts[1]||1); for(let i=0;i<t;i++) tick(1); out.push('Advanced ' + t + 's'); }
      else if(cmd === 'help'){ out.push('Commands: credits <n>, income <n>, spawn <sysId?> <owner> <str>, list systems|fleets, setowner <sysId> <owner>, clearfleets, tick <seconds>, help'); }
      else out.push('Unknown command: ' + cmd + ' (type help)');
    } catch(e){ out.push('Error: ' + e.message); }
  }
  updateSelectionUI(); draw(); return out.join('\n');
}

/* ===== Drawing ===== */
function draw(){
  if(!G.ctx || !G.canvas) return;
  const ctx = G.ctx, canvas = G.canvas;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#041226'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // sectors (hull)
  for(let sec of G.sectors){
    if(sec.hull && sec.hull.length>=3){
      ctx.save();
      ctx.beginPath();
      for(let i=0;i<sec.hull.length;i++){
        const p = sec.hull[i];
        const s = worldToScreen(p.x,p.y);
        if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
      }
      ctx.closePath();
      ctx.fillStyle = sec.color;
      ctx.fill();
      ctx.restore();
    }
  }

  // edges/starlanes
  for(let e of G.edges){
    const sa = worldToScreen(e.a.x,e.a.y), sb = worldToScreen(e.b.x,e.b.y);
    ctx.beginPath();
    ctx.lineWidth = Math.max(1, 1.5 * G.view.scale);
    const owner = laneOwner(e);
    ctx.strokeStyle = owner===0? 'rgba(160,170,190,0.14)' : getPlayerColor(owner,'lane');
    ctx.moveTo(sa.x,sa.y); ctx.lineTo(sb.x,sb.y); ctx.stroke();
  }

  // hovered edge
  if(G.hoverEdge){
    const e = G.hoverEdge;
    const sa = worldToScreen(e.a.x,e.a.y), sb = worldToScreen(e.b.x,e.b.y);
    ctx.beginPath(); ctx.moveTo(sa.x,sa.y); ctx.lineTo(sb.x,sb.y);
    ctx.lineWidth = 4 * G.view.scale; ctx.strokeStyle = 'rgba(255,255,0,0.6)'; ctx.stroke();
  }

  // systems
  for(let s of G.systems){
    const sc = worldToScreen(s.x,s.y);
    ctx.beginPath();
    // compute radius from production (include mine bonuses); scale with view
    const prod = (s.baseProd || 0) + (s.mines ? s.mineBonus || 0 : 0);
    // radius base and scaling: make small systems still visible but larger ones noticeably bigger
    const baseR = 4; // world units
    const scaleR = 4; // multiplier for production influence
    const rWorld = Math.max(3, baseR + scaleR * Math.sqrt(prod));
    const r = rWorld * G.view.scale;
    const fill = s.owner===0? '#b0b8c6' : getPlayerColor(s.owner,'system');
    ctx.fillStyle = fill;
    ctx.arc(sc.x, sc.y, r, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth=1; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.stroke();
    // Label decluttering: only draw many labels when zoomed in enough; always draw for selected/hovered
    // Collision avoidance: don't draw labels that overlap previously drawn labels
    const LABEL_SYSTEM_MIN_SCALE = 0.6; // below this, most system labels are hidden
    const LABEL_FLEET_MIN_SCALE = 0.85; // fleet strength numbers hidden below this
    const LABEL_SECTOR_MIN_SCALE = 0.7; // sector labels hidden below this
    // Prepare collision tracking array on ctx (keeps screen-space rects)
    if(!ctx._labelRects) ctx._labelRects = [];
    // helper to test overlap and register
    function rectsOverlap(a,b){ return !(a.x+b.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }
    function canPlaceLabel(x,y,w,h){
      const rect = {x: x, y: y, w: w, h: h};
      for(const rct of ctx._labelRects){ if(rectsOverlap(rect, rct)) return false; }
      ctx._labelRects.push(rect); return true;
    }

    // draw system name: prefer selected/hovered always
    ctx.font = `${Math.max(10, 10*G.view.scale)}px sans-serif`;
    const labelX = sc.x + (r + 6);
    const labelY = sc.y - (r - 4);
    const isImportant = (G.selectedSystem === s) || (G.hoverNode === s);
    const showSystemLabel = isImportant || G.view.scale >= LABEL_SYSTEM_MIN_SCALE;
    if(showSystemLabel){
      // measure and avoid collisions at smaller scales
      const metrics = ctx.measureText(s.name);
      const textW = metrics.width + 6;
      const textH = Math.max(12, 10 * G.view.scale) + 4;
      // when zoomed out a bit, reduce opacity
      const alpha = isImportant ? 0.98 : clamp((G.view.scale - 0.35) / (1.0 - 0.35), 0.2, 0.98);
      if(isImportant || canPlaceLabel(labelX, labelY - textH, textW, textH)){
        ctx.fillStyle = `rgba(220,230,255,${alpha})`;
        ctx.fillText(s.name, labelX, labelY);
      }
    }

    // draw mines (multiple) — position relative to radius
    if(s.mines){
      for(let i=0;i<s.mines;i++){
        const offset = (i - (s.mines-1)/2) * (10 * G.view.scale);
        drawHex(ctx, sc.x + offset, sc.y + (r + 6), 5*G.view.scale, '#d0b84a');
      }
    }
    // draw shipyard near bottom-right of the system circle
    if(s.buildings.shipyard) drawSquare(ctx, sc.x + (r - 1), sc.y + (r + 6), Math.max(6, 8*G.view.scale), '#9ad4ff');

    // draw outposts as stars above the system, spaced by radius
    if(s.buildings.outposts){
      for(let i=0;i<s.buildings.outposts;i++){
        const offset = (i - (s.buildings.outposts-1)/2) * (10 * G.view.scale);
        drawStar(ctx, sc.x + offset, sc.y - (r + 8), 5*G.view.scale, '#ffd700');
      }
    }

    // optionally draw defense number, positioned under the system — show when zoomed in or selected/hovered
    const DEFENSE_MIN_SCALE = 0.7;
    ctx.font = `${Math.max(9, 9*G.view.scale)}px sans-serif`;
    const showDefense = isImportant || G.view.scale >= DEFENSE_MIN_SCALE;
    if(showDefense){ ctx.fillStyle='rgba(200,230,255,0.85)'; ctx.fillText(s.defense, sc.x - (r * 0.5), sc.y + (r + 4)); }
  }

  // sector labels
  for(let sec of G.sectors){
    if(sec.systems.length){
      const avgX = sec.systems.reduce((a,b)=>a+b.x,0)/sec.systems.length;
      const avgY = sec.systems.reduce((a,b)=>a+b.y,0)/sec.systems.length;
      const p = worldToScreen(avgX,avgY);
      // only draw sector labels when zoomed sufficiently or if any contained system is hovered/selected
      const sectorImportant = sec.systems.some(s => G.selectedSystem === s || G.hoverNode === s);
      if(sectorImportant || G.view.scale >= LABEL_SECTOR_MIN_SCALE){
        ctx.font = `${12*G.view.scale}px sans-serif`; ctx.fillStyle='rgba(200,220,255,0.6)';
        // avoid overlapping with previously drawn labels
        const text = sec.name;
        const metrics = ctx.measureText(text);
        const tw = metrics.width + 6, th = 14 * Math.max(1, G.view.scale);
        if(sectorImportant || canPlaceLabel(p.x-20, p.y-8-th, tw, th)) ctx.fillText(text, p.x-20, p.y-8);
      }
    }
  }

  // fleets
  for(let f of G.fleets){
    const p = worldToScreen(f.pos.x,f.pos.y);
    drawTriangle(ctx, p.x, p.y, f);
    ctx.fillStyle='white'; ctx.font = `${11*G.view.scale}px sans-serif`; ctx.fillText(f.strength, p.x+8, p.y-6);
  }

  // selection highlight (system)
  if(G.selectedSystem){
    const s = G.selectedSystem; const sc = worldToScreen(s.x,s.y);
    ctx.beginPath(); ctx.arc(sc.x, sc.y, 12*G.view.scale,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth = 2; ctx.stroke();
  }

  // selection highlight (fleets)
  if(G.selectedFleets.length>0){
    for(let f of G.selectedFleets){
      const p = worldToScreen(f.pos.x,f.pos.y);
      ctx.beginPath(); ctx.arc(p.x,p.y,12*G.view.scale,0,Math.PI*2); ctx.strokeStyle='yellow'; ctx.lineWidth=2; ctx.stroke();
    }
  }

  // draw selection rect if exists (screen coords)
  if(G._selRect){
    const r = G._selRect;
    const x = Math.min(r.x0, r.x1), y = Math.min(r.y0, r.y1), w = Math.abs(r.x1 - r.x0), h = Math.abs(r.y1 - r.y0);
    ctx.save();
    ctx.strokeStyle='rgba(200,200,255,0.9)'; ctx.setLineDash([6,6]); ctx.strokeRect(x,y,w,h);
    ctx.restore();
  }

  // minimap
  drawMinimap();
}

function drawTriangle(ctx,x,y,f){
  ctx.save(); ctx.translate(x,y);
  let angle = 0;
  if(f.moving && f._from && f._to) angle = Math.atan2(f._to.y - f._from.y, f._to.x - f._from.x);
  ctx.rotate(angle);
  const s = 6 * Math.max(1, G.view.scale);
  // draw outline for contrast
  ctx.beginPath(); ctx.moveTo(s,0); ctx.lineTo(-s*0.7, s*0.7); ctx.lineTo(-s*0.7, -s*0.7); ctx.closePath();
  // choose outline color based on fleet color lightness: dark outline for light colors, light outline for dark colors
  const fleetColor = getPlayerColor(f.owner,'fleet');
  // crude luminance estimate from HSL lightness used earlier; if lightness >= 55 use dark outline
  const useDarkOutline = true; // prefer dark outline for most colors for readability
  ctx.lineWidth = Math.max(1.5, 2 * G.view.scale);
  ctx.strokeStyle = useDarkOutline ? 'rgba(6,10,18,0.85)' : 'rgba(255,255,255,0.9)';
  ctx.stroke();
  // fill the triangle
  ctx.fillStyle = fleetColor;
  ctx.fill();
  ctx.restore();
}
function drawHex(ctx,x,y,r,color){ ctx.save(); ctx.translate(x,y); ctx.beginPath(); for(let i=0;i<6;i++){ const a = Math.PI/3 * i; const px = Math.cos(a)*r, py = Math.sin(a)*r; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); } ctx.closePath(); ctx.fillStyle=color; ctx.fill(); ctx.restore(); }
function drawStar(ctx,x,y,r,color){
  ctx.save(); ctx.beginPath();
  for(let i=0;i<5;i++){
    const angle = i * Math.PI*2/5 - Math.PI/2;
    const x1 = x + Math.cos(angle)*r;
    const y1 = y + Math.sin(angle)*r;
    const angle2 = angle + Math.PI/5;
    const x2 = x + Math.cos(angle2)*r*0.5;
    const y2 = y + Math.sin(angle2)*r*0.5;
    if(i===0) ctx.moveTo(x1,y1);
    else ctx.lineTo(x1,y1);
    ctx.lineTo(x2,y2);
  }
  ctx.closePath();
  ctx.fillStyle=color; ctx.fill(); ctx.restore();
}

function drawSquare(ctx,x,y,s,color){ ctx.save(); ctx.beginPath(); ctx.rect(x - s/2, y - s/2, s, s); ctx.fillStyle=color; ctx.fill(); ctx.restore(); }

function laneOwner(edge){
  if(edge.a.owner===edge.b.owner) return edge.a.owner || 0;
  if(edge.a.owner===1 || edge.b.owner===1) return 1;
  for(let pid in G.players){
    const ip = Number(pid);
    if(ip>1 && (edge.a.owner===ip || edge.b.owner===ip)) return ip;
  }
  return 0;
}

function drawMinimap(){
  if(!G.minimapCtx) return;
  const ctx = G.minimapCtx; const w=200, h=120; ctx.clearRect(0,0,w,h);
  ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(0,0,w,h);
  const fx = w / G.width, fy = h / G.height;
  ctx.lineWidth=1;
  for(let e of G.edges){ ctx.beginPath(); ctx.moveTo(e.a.x*fx, e.a.y*fy); ctx.lineTo(e.b.x*fx, e.b.y*fy); ctx.strokeStyle='rgba(200,200,220,0.12)'; ctx.stroke(); }
  for(let s of G.systems){ ctx.fillStyle = s.owner===1? getPlayerColor(1,'minimap') : s.owner>1? getPlayerColor(s.owner,'minimap') : '#b0b8c6'; ctx.fillRect(s.x*fx - 1, s.y*fy -1, 2,2); }
  const vx = (G.view.x - (G.canvas.width / 2) / G.view.scale) * fx;
  const vy = (G.view.y - (G.canvas.height / 2) / G.view.scale) * fy;
  const vw = (G.canvas.width / G.view.scale) * fx;
  const vh = (G.canvas.height / G.view.scale) * fy;
  ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.strokeRect(vx,vy,vw,vh);
}

/* ===== Win conditions ===== */
function checkWinConditions(){
  const otherSystems = G.systems.filter(s=>s.owner && s.owner !== 1).length;
  const otherFleets = G.fleets.filter(f=>f.owner !== 1).length;
  const playerSystems = G.systems.filter(s=>s.owner===1).length;
  const playerFleets = G.fleets.filter(f=>f.owner===1).length;
  const isSpectator = G.players[1] && G.players[1].isSpectator;

  // If no opposing systems/fleets remain, end the match. For spectators show a neutral message.
  if(otherSystems===0 && otherFleets===0){
    setTimeout(()=>{ 
      if(isSpectator) alert('Match ended — no AI opponents remain');
      else alert('You Win!');
      stopGame();
    }, 10);
  }

  // Only trigger 'AI Wins' when the human player is actually participating (not spectating)
  if(!isSpectator && playerSystems===0 && playerFleets===0){
    setTimeout(()=>{ alert('AI Wins!'); stopGame(); }, 10);
  }
}

/* ===== Start / Stop ===== */
let rafId=null, lastTime=performance.now();
function startGame(settings){
  G.settings = settings;
  generateGalaxy(settings);
  document.getElementById('menu').style.display='none';
  document.getElementById('topBar').style.display='flex';
  document.getElementById('hud').style.display='block';
  document.getElementById('footer').style.display='block';
  document.getElementById('statusText').textContent = 'Running — Seed: ' + (G.seed||'random');

  for(let pid in G.players){ if(G.players[pid].isAI){ G.players[pid].credits = 300 * settings.difficulty; G.players[pid].difficulty = settings.difficulty; } }

  // starter fleets
  const pStart = G.playerStart || G.systems.find(s=>s.owner===1);
  if(pStart) G.fleets.push(new Fleet(G.nextFleetId++,1,3,pStart));
  for(let pid in G.players){ if(G.players[pid].isAI){ const s = G.systems.find(x=>x.owner==pid); if(s) G.fleets.push(new Fleet(G.nextFleetId++, parseInt(pid), Math.max(1,2 + Math.floor(Math.random()*3)), s)); } }

  // center & zoom on player's starting system
  if(pStart){
    const targetScale = 1.2;
    // Snap view immediately to ensure centering works across browsers; then perform a small animation to settle
    G.view.x = pStart.x; G.view.y = pStart.y; G.view.scale = targetScale;
    try{ resize(); draw(); } catch(e) { if(G.canvas) draw(); }
    // also perform a brief animate to give a smooth effect from current (redundant but harmless)
    try{ animateViewTo(pStart.x, pStart.y, targetScale, 0.6); } catch(e){ /* ignore */ }

    // Hide left pane and dev console UI on game start so the player gets an unobstructed view
    try{
      const leftToggle = document.getElementById('toggleLeftPane');
      const devToggle = document.getElementById('toggleDevConsole');
      if(leftToggle){ leftToggle.checked = false; const lp = document.getElementById('leftPane'); if(lp) lp.style.display = 'none'; }
      if(devToggle){ devToggle.checked = false; const dp = document.getElementById('devConsolePanel'); if(dp) dp.style.display = 'none'; }
      // trigger a resize event so the canvas recalculates dimensions (resize listener calls resize())
      setTimeout(()=>{ try{ window.dispatchEvent(new Event('resize')); }catch(e){ if(G.canvas) draw(); } }, 80);
    } catch(e) { /* ignore UI hide errors */ }
  }

  G.running = true; lastTime = performance.now();
  function loop(t){
    const dt = Math.min(0.1, (t - lastTime)/1000);
    lastTime = t;
    tick(dt);
    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);
}

// Smoothly animate the view (center and zoom) to target position/scale over duration (seconds)
function animateViewTo(tx, ty, tscale, duration = 0.8){
  const startX = G.view.x, startY = G.view.y, startS = G.view.scale;
  const startTime = performance.now();
  function step(now){
    const t = Math.min(1, (now - startTime) / (duration * 1000));
    const ease = (t<0.5) ? (2*t*t) : (-1 + (4-2*t)*t); // smooth ease in/out
    G.view.x = lerp(startX, tx, ease);
    G.view.y = lerp(startY, ty, ease);
    G.view.scale = lerp(startS, tscale, ease);
    resize(); draw();
    if(t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

function stopGame(){
  // Defensive stop: cancel animation loop, clear AI timers, reset UI flags and selection
  G.running = false;
  try{ if(rafId) cancelAnimationFrame(rafId); }catch(e){ /* ignore */ }
  rafId = null;

  // Clear per-AI timers/state used by aiTick
  if(G._aiTimers) G._aiTimers = {};
  for(let pid in G.players){ if(G.players[pid]) G.players[pid]._nextAiActionAt = 0; }

  // Reset user interaction modes
  G.sendMode = false;
  try{ const sendBtn = document.getElementById('sendFleet'); if(sendBtn) sendBtn.textContent = 'Send Fleet'; }catch(e){}
  G.selectedFleets = [];
  G.selectedSystem = null;

  // Restore main menu & left UI panels so the player can reconfigure game
  try{ document.getElementById('menu').style.display='block'; }catch(e){}
  try{ document.getElementById('leftPane').style.display='block'; }catch(e){}
  try{ document.getElementById('devConsolePanel').style.display='block'; }catch(e){}

  // Hide in-game HUD elements
  try{ document.getElementById('topBar').style.display='none'; }catch(e){}
  try{ document.getElementById('hud').style.display='none'; }catch(e){}
  try{ document.getElementById('footer').style.display='none'; }catch(e){}

  // Re-enable any player-specific controls that spectate mode may have disabled
  try{
    ['buildMine','buildShipyard','buildOutpost','buildFleet','sendFleet','autoCapture','stopAutoCapture'].forEach(id=>{
      const el = document.getElementById(id); if(el) el.disabled = false;
    });
    if(G.players[1]) G.players[1].isSpectator = false;
  } catch(e){}

  // Force a redraw to reflect stopped state
  try{ draw(); }catch(e){}
}

/* ===== Spectate Mode =====
   startSpectate(settings): Launch a game where the player is set to spectator (no player-owned systems or fleets)
   and the AIs play against each other. HUD is shown read-only and player controls are disabled.
*/
function startSpectate(settings){
  // Start the game normally
  startGame(settings);
  // Immediately convert player (id 1) to a spectator: remove ownership and fleets
  // Make a shallow snapshot of player data so we can restore if needed (not strictly necessary)
  try{
    // Remove any player-owned systems: set them to neutral (owner 0)
    for(const s of G.systems){ if(s.owner === 1) s.owner = 0; }
    // Remove player fleets
    for(const f of G.fleets.slice()){ if(f.owner === 1) removeFleet(f); }
    // Remove player entry so player controls think there's no player
    if(G.players[1]) G.players[1].isSpectator = true;

    // Hide or disable player-specific controls in the HUD/menu
    try{ document.getElementById('buildMine').disabled = true; }catch(e){}
    try{ document.getElementById('buildShipyard').disabled = true; }catch(e){}
    try{ document.getElementById('buildOutpost').disabled = true; }catch(e){}
    try{ document.getElementById('buildFleet').disabled = true; }catch(e){}
    try{ document.getElementById('sendFleet').disabled = true; }catch(e){}
    try{ document.getElementById('autoCapture').disabled = true; }catch(e){}
    try{ document.getElementById('stopAutoCapture').disabled = true; }catch(e){}

    // Update HUD display to indicate spectating
    const status = document.getElementById('statusText'); if(status) status.textContent = 'Spectating AI — Seed: ' + (G.seed||'random');
    // Keep HUD visible but read-only
    document.getElementById('hud').style.display = 'block';
    document.getElementById('footer').style.display = 'block';

    // Make sure updateSelectionUI doesn't try to show player credits
    if(G.players[1]){ G.players[1].credits = 0; G.players[1].income = 0; }
    updateSelectionUI(); draw();
  } catch(e){ console.error('startSpectate error', e); }
}

/* ===== Init ===== */
setupUI();
G.settings.systems = 120; G.settings.aiCount = 3; G.settings.difficulty = 1.0;
generateGalaxy(G.settings);
draw();

</script>
</body>
</html>
