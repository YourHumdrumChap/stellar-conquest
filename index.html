<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Galactic Conquest — RTS Prototype (Fixed)</title>
  <style>
    :root{--bg:#071025;--panel:#0f1626;--accent:#4ea3ff;--accent2:#ff6b6b;--muted:#98a0b3}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#dbe6ff;background:linear-gradient(180deg,#031020 0%, #05122a 70%);}
    #container{display:flex;height:100vh;gap:12px;padding:14px;box-sizing:border-box}
    #leftPane{width:300px;flex-shrink:0}
    #menu,#settings{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    h1{font-size:18px;margin:0 0 12px 0}
    label{display:block;margin-top:8px;font-size:13px;color:var(--muted)}
    input[type=range], input[type=number]{width:100%}
    select,button,input{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button.primary{background:linear-gradient(90deg,var(--accent),#2ec4ff);color:#021022;border:none;font-weight:600}
    #gameArea{flex:1;position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#061122,#071426)}
    #topBar{position:absolute;left:12px;top:12px;z-index:50;background:rgba(5,8,15,0.6);padding:8px;border-radius:8px;display:flex;gap:8px;align-items:center}
    #hud{position:absolute;right:12px;top:12px;z-index:50;background:rgba(5,8,15,0.6);padding:8px;border-radius:8px;min-width:260px}
    #canvasWrap{width:100%;height:100%;display:flex}
    canvas#gameCanvas{flex:1;display:block;cursor:crosshair}
    .panel{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    .systemInfo{font-size:13px;margin-top:8px}
    .btnRow{display:flex;gap:8px;margin-top:8px}
    .controlBtn{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    #footer{position:absolute;left:12px;bottom:12px;z-index:20;color:var(--muted);font-size:12px}
    .legend{display:flex;gap:8px;align-items:center}
    .legend .dot{width:12px;height:12px;border-radius:3px}
    #minimap{width:200px;height:120px;border-radius:8px;background:rgba(0,0,0,0.12);margin-top:8px}
    .progressBar{height:8px;background:rgba(255,255,255,0.06);border-radius:6px;overflow:hidden}
    .progressFill{height:100%;background:linear-gradient(90deg,var(--accent),#2ec4ff);width:0%}
    @media (max-width:900px){#leftPane{display:none}}    
  </style>
</head>
<body>
  <div id="container">
    <div id="leftPane">
      <div id="menu">
        <h1>Galactic Conquest</h1>
        <div class="small">A lightweight real-time strategy prototype — HTML + JS. Configure and Launch.</div>

        <label for="difficulty">AI Difficulty</label>
        <select id="difficulty">
          <option value="0.6">Very Easy</option>
          <option value="0.8">Easy</option>
          <option value="1.0" selected>Normal</option>
          <option value="1.25">Hard</option>
          <option value="1.6">Very Hard</option>
          <option value="2.2">Insane</option>
        </select>

        <label for="aiCount">Number of AI Opponents <span id="aiCountLabel">3</span></label>
        <input id="aiCount" type="range" min="1" max="100" value="3">

        <label for="systemsRange">Number of Star Systems <span id="sysCount">120</span></label>
        <input id="systemsRange" type="range" min="5" max="1000" value="120">

        <label for="seed">Galaxy Seed (optional)</label>
        <input id="seed" placeholder="leave blank for random" />

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="launchBtn" class="primary">Launch</button>
          <button id="loadExample">Example</button>
        </div>

        <div class="panel">
          <div class="small">Controls</div>
          <ul class="small">
            <li>Click a system to select it.</li>
            <li>Build fleets in controlled systems that have a shipyard.</li>
            <li>Drag to select fleets, click "Send Fleet", then click destination.</li>
            <li>Zoom with mouse wheel. Pan with right-drag (hold RMB).</li>
          </ul>
        </div>
      </div>

      <div id="settings" style="margin-top:12px">
        <div class="small">Tips</div>
        <div class="small systemInfo" id="tipsText">Capture systems, build mines to increase income, build shipyards to produce fleets. AI difficulty affects budget and aggressiveness.</div>
      </div>
    </div>

    <div id="gameArea">
      <div id="topBar" style="display:none">
        <button id="toMenu">Main Menu</button>
        <div class="small" id="statusText">Status:</div>
      </div>

      <div id="hud" style="display:none">
        <div class="small">Credits: <span id="credits">0</span></div>
        <div class="small">Income/sec: <span id="income">0</span></div>
        <div class="small">Time: <span id="timeLabel">0s</span></div>

        <div class="panel">
          <div class="small">Selected</div>
          <div id="selectedName" class="systemInfo">None</div>
          <div id="selectedOwner" class="small"></div>
          <div id="selectedIncome" class="small"></div>
          <div class="btnRow">
            <button id="buildMine">Build Mine (Cost: <span id="mineCost">80</span>)</button>
            <button id="buildShipyard">Build Shipyard (Cost: <span id="yardCost">120</span>)</button>
          </div>
          <div style="margin-top:8px" class="small">Build Queue</div>
          <div id="buildQueue"></div>
        </div>

        <div class="panel">
          <div class="small">Fleets</div>
          <div class="small">Selected Fleets: <span id="selFleetCount">0</span></div>
          <div class="btnRow" style="margin-top:8px">
            <button id="buildFleet">Build Fleet (Cost: <span id="buildCost">100</span>)</button>
            <button id="sendFleet">Send Fleet</button>
          </div>
        </div>

        <div class="panel">
          <div class="small">Zoom</div>
          <input id="zoomSlider" type="range" min="0.3" max="2.5" step="0.05" value="1">
          <div class="small" style="margin-top:6px">Minimap</div>
          <canvas id="minimap" width="200" height="120"></canvas>
        </div>
      </div>

      <div id="canvasWrap">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div id="footer" style="display:none">
        <div class="legend">
          <div class="dot" style="background:#4ea3ff"></div><div class="small">Player</div>
          <div class="dot" style="background:#b0b8c6"></div><div class="small">Neutral</div>
          <div class="dot" style="background:#ff6b6b"></div><div class="small">AI</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===== Fixed Galactic Conquest RTS - Single HTML File =====
   This file fixes and extends the provided prototype.
   Implemented improvements:
   - Menu supports 6 difficulties, 1-100 AI opponents, 5-1000 systems
   - Multi-AI players supported (IDs 2..N)
   - Procedural galaxy with sectors, hulls, names, starlanes
   - Building system (mines & shipyards) with build time (7s) and visual queue
   - Fleet production time (5s) and production queue
   - Drag-select fleets, send selected fleets to a destination
   - Fleets attempt to conquer systems on arrival and continue along path
   - Pan (right-drag), zoom (wheel & slider) and minimap
   - Simple AI for each opponent with difficulty multiplier
*/

// ========== Utilities ==========
function seededRNG(seed){
  // FNV-1a seeding then xorshift mix
  let h = 2166136261 >>> 0;
  for(let i=0;i<seed.length;i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
  return function(){ h += 0x6D2B79F5; let t = Math.imul(h ^ (h >>> 15), 1 | h); t ^= t + Math.imul(t ^ (t >>> 7), 61 | t); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }
}
function choice(rng,arr){ return arr[Math.floor(rng()*arr.length)]; }
function lerp(a,b,t){ return a + (b-a)*t; }
function dist(a,b){ let dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
const SYLL = ["sol","ar","ta","ri","zen","kor","nal","vex","lon","or","ima","tur","sha","bel","tek","zar","ion","qua","dra","lyr","neo","exa","pon","mar","vel","stel"]; 
function makeName(rng, parts=2){ let s=""; for(let i=0;i<parts;i++) s += choice(rng,SYLL); return s.charAt(0).toUpperCase() + s.slice(1); }
function pointLineDist(px,py,x1,y1,x2,y2){ // distance from point to segment
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const len2 = C*C + D*D;
  let t = len2 === 0 ? 0 : dot / len2;
  t = Math.max(0, Math.min(1, t));
  const projx = x1 + C * t, projy = y1 + D * t;
  return Math.hypot(px - projx, py - projy);
}

// Convex hull (Graham-like)
function convexHull(points){ if(points.length<3) return points.slice(); let pts = points.slice().sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x); }
  let lower=[]; for(let p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  let upper=[]; for(let i=pts.length-1;i>=0;i--){ let p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop(); return lower.concat(upper);
}

// ========== Classes ==========
class SystemNode{
  constructor(id,x,y,sector,name){ this.id=id; this.x=x; this.y=y; this.sector=sector; this.name=name; this.owner=0; this.defense=0; this.baseProd=0; this.buildings={mine:false,shipyard:false}; this.queue=[]; this.connected=[]; }
}
class Sector{ constructor(id,color,name){ this.id=id; this.color=color; this.name=name; this.systems=[]; this.owner=0; this.hull=[]; } }
class Fleet{ constructor(id,owner,strength,currentNode){ this.id=id; this.owner=owner; this.strength=strength; this.currentNode=currentNode; this.pos={x:currentNode.x,y:currentNode.y}; this.moving=false; this._from=null; this._to=null; this.progress=0; this.speed=90 + Math.random()*30; this.path=[]; this.pathIndex=0; } }

// ========== Game State ==========
const G = {
  rng: Math.random,
  systems:[], sectors:[], edges:[], fleets:[], players:{}, settings:{systems:120, difficulty:1.0, aiCount:3, seed:null},
  time:0, running:false, selectedSystem:null, selectedFleets:[], sendMode:false, selectedFleet:null,
  view:{x:0,y:0,scale:1}, canvas:null, ctx:null, minimapCtx:null, hoverEdge:null, hoverNode:null,
  nextFleetId:1, nextSystemId:1, width:3000, height:1800
};

function resetGame(){ G.systems=[]; G.sectors=[]; G.fleets=[]; G.edges=[]; G.players={}; G.nextFleetId=1; G.nextSystemId=1; G.time=0; G.selectedSystem=null; G.selectedFleets=[]; G.sendMode=false; G.hoverEdge=null; }

// ========== Galaxy Generation ==========
function generateGalaxy(settings){ resetGame(); const seed = settings.seed || (Math.random().toString(36).slice(2)); G.seed = seed; G.rng = seededRNG(seed + '_galaxy'); const rng = G.rng; const W = G.width = 3000, H = G.height = 1800; const total = Math.max(5, Math.min(1000, settings.systems || 120));
  // sectors count based on size
  const sectorsCount = Math.max(3, Math.min(20, Math.round(total / (40 + rng()*20))));
  // create sector centers
  let sectorCenters = [];
  for(let i=0;i<sectorsCount;i++){ const cx = 120 + rng()*(W-240); const cy = 120 + rng()*(H-240); sectorCenters.push({x:cx,y:cy}); const hue = Math.floor(rng()*360); const color = `hsl(${hue} 70% 45% / 0.18)`; const name = makeName(rng,2) + ' Sector'; G.sectors.push(new Sector(i,color,name)); }
  // distribute systems
  let assigned = 0;
  for(let i=0;i<sectorsCount;i++){
    let remaining = total - assigned; let remainingSectors = sectorsCount - i; let take = Math.max(1, Math.floor(rng()*(remaining/remainingSectors*1.6) + 1)); if(i===sectorsCount-1) take = remaining; assigned += take;
    for(let s=0;s<take;s++){ const jitter = 50 + rng()*220; const ang = rng()*Math.PI*2; const cx = sectorCenters[i].x + Math.cos(ang)*rng()*jitter; const cy = sectorCenters[i].y + Math.sin(ang)*rng()*jitter; const sys = new SystemNode(G.nextSystemId++, cx, cy, i, makeName(rng,1 + Math.round(rng()*2))); sys.baseProd = Math.max(1, Math.floor(3 + rng()*12)); sys.defense = Math.max(0, Math.floor(2 + rng()*10)); G.systems.push(sys); G.sectors[i].systems.push(sys); }
  }
  // create k-nearest edges
  const k = 3 + Math.floor(rng()*3);
  for(let a of G.systems){ let dists = G.systems.map(b=>({b, d: dist(a,b)})).filter(o=>o.b!==a).sort((x,y)=>x.d-y.d); for(let i=0;i<Math.min(k,dists.length);i++){ addEdge(a,dists[i].b); } }
  ensureConnected(rng);
  // add cross-sector lanes
  for(let i=0;i<G.sectors.length;i++){ for(let j=i+1;j<G.sectors.length;j++){ if(rng()<0.25){ const a = choice(rng, G.sectors[i].systems); const b = choice(rng, G.sectors[j].systems); addEdge(a,b); } } }
  // sector hulls
  for(let sec of G.sectors){ sec.hull = convexHull(sec.systems.map(s=>({x:s.x,y:s.y}))); }
  // assign starting positions: player at center-most, AIs at spread
  G.systems.sort((a,b)=>Math.hypot(a.x-W/2,a.y-H/2)-Math.hypot(b.x-W/2,b.y-H/2));
  const playerStart = G.systems[0]; playerStart.owner = 1; playerStart.defense = Math.max(playerStart.defense, 18); playerStart.baseProd += 8; playerStart.buildings.mine = true; // provide small start
  // create players object: id 1 = human, 2..n = ai
  G.players[1] = {id:1, name:'Player', credits:400, income:0, isAI:false, difficulty:1.0};
  const aiCount = Math.max(1, Math.min(100, settings.aiCount || 3));
  // spread AI starts
  for(let i=0;i<aiCount;i++){ const pid = 2 + i; G.players[pid] = {id:pid, name:'AI-'+(i+1), credits:300 * settings.difficulty, income:0, isAI:true, difficulty: settings.difficulty}; const idx = Math.floor((i+1)*G.systems.length/(aiCount+2)); const s = G.systems[Math.min(G.systems.length-1, idx)]; s.owner = pid; s.defense = Math.max(s.defense, 12); s.baseProd += 6; }
  // recalc incomes
  recalcIncome();
  // set view center
  G.view.x = W/2; G.view.y = H/2; G.view.scale = clamp(lerp(0.6,1.0, 1 - Math.min(1, total/600)), 0.4, 1.2);
}

function addEdge(a,b){ if(a===b) return; for(let e of G.edges){ if((e.a===a && e.b===b) || (e.a===b && e.b===a)) return; } G.edges.push({a:a,b:b}); a.connected.push(b); b.connected.push(a); }

function ensureConnected(rng){ // simple connect by nearest representative
  if(G.edges.length===0) return;
  const visited = new Set(); function dfs(s, comp){ visited.add(s); for(let n of s.connected) if(!visited.has(n)) dfs(n,comp); }
  const comps = [];
  for(let s of G.systems){ if(!visited.has(s)){ const comp=[]; const stack=[s]; visited.add(s); while(stack.length){ let cur=stack.pop(); comp.push(cur); for(let n of cur.connected) if(!visited.has(n)){ visited.add(n); stack.push(n); } } comps.push(comp); } }
  for(let i=0;i<comps.length-1;i++){ const a = choice(G.rng, comps[i]); const b = choice(G.rng, comps[i+1]); addEdge(a,b); }
}

function recalcIncome(){ for(let pid in G.players){ G.players[pid].income = 0; } for(let s of G.systems){ if(s.owner && G.players[s.owner]){ let prod = s.baseProd + (s.buildings.mine? Math.floor(s.baseProd * 1.2) + 2 : 0); G.players[s.owner].income += prod; } } }

// ========== Game Loop & Logic ==========
function tick(dt){ if(!G.running) return; G.time += dt;
  // economy
  for(let pid in G.players){ const p = G.players[pid]; p.credits += p.income * dt; }
  // process system queues (first-in-first-out)
  for(let s of G.systems){ if(s.queue.length>0){ let task = s.queue[0]; task.timeLeft -= dt; if(task.timeLeft <= 0){ // finish
        const finished = s.queue.shift(); applyBuilt(s, finished); }
    }}
  // fleet movement
  for(let f of G.fleets.slice()){ if(f.moving && f._from && f._to){ const from=f._from, to=f._to; const edgeLen = dist(from,to); if(edgeLen===0) continue; f.progress += f.speed * dt * 100 / edgeLen; const t = clamp(f.progress/100,0,1); f.pos.x = lerp(from.x,to.x,t); f.pos.y = lerp(from.y,to.y,t);
        if(f.progress>=100){ // arrived at node 'to'
            f.currentNode = to; f.pos.x = to.x; f.pos.y = to.y; f.moving = false; f._from = null; f._to = null; f.progress = 0;
            const survived = resolveArrival(f);
            if(!survived){ /* fleet removed inside resolveArrival */ continue; }
            // continue along path if there are remaining nodes
            if(f.path && f.pathIndex < f.path.length-1){ // pathIndex currently points at arrived node index
                if(f.pathIndex+1 < f.path.length){ const next = f.path[f.pathIndex+1]; f._from = f.path[f.pathIndex]; f._to = next; f.moving = true; f.pathIndex++; f.progress = 0; }
            }
        }
    }}
  // merging stationary fleets
  mergeFleetsAtNodes();
  // AI actions
  aiTick(dt);
  // recalc income and UI
  recalcIncome(); updateSelectionUI(); draw(); checkWinConditions();
}

function applyBuilt(system, task){ if(task.type==='mine'){ system.buildings.mine = true; system.baseProd += Math.max(2, Math.floor(system.baseProd * 0.8)); }
  else if(task.type==='shipyard'){ system.buildings.shipyard = true; }
  else if(task.type==='fleet'){ const fleet = new Fleet(G.nextFleetId++, task.owner, task.strength || 1, system); G.fleets.push(fleet); }
}

function resolveArrival(f){ const node = f.currentNode; if(!node) return true; // safety
  if(node.owner === f.owner){ // friendly: add to garrison
    node.defense += Math.round(f.strength * 0.8);
    removeFleet(f); return false; // fleet absorbed
  }
  // attacking
  if(f.strength > node.defense){ const leftover = f.strength - node.defense; // conquer: per spec, new fleet strength = old - defense
    node.owner = f.owner; node.defense = Math.max(1, Math.round(node.defense * 0.4)); f.strength = Math.max(1, Math.round(leftover)); recalcIncome(); return true; // fleet survives
  } else if(f.strength === node.defense){ // mutual destruction
    node.defense = 0; removeFleet(f); return false;
  } else { // fleet destroyed, defenders reduced slightly
    node.defense = Math.max(0, node.defense - Math.round(f.strength * 0.6)); removeFleet(f); return false; }
}

function mergeFleetsAtNodes(){ const map = new Map(); for(let f of G.fleets){ if(!f.moving){ const key = f.currentNode.id + '-' + f.owner; if(!map.has(key)) map.set(key,[]); map.get(key).push(f); }} for(let [k, arr] of map){ if(arr.length>1){ const base = arr[0]; for(let i=1;i<arr.length;i++){ base.strength += arr[i].strength; removeFleet(arr[i]); } } } }

function removeFleet(f){ const idx = G.fleets.indexOf(f); if(idx>=0) G.fleets.splice(idx,1); }

// ========== AI ==========
function aiTick(dt){ if(!G._aiTimers) G._aiTimers = {}; for(let pid in G.players){ const p = G.players[pid]; if(!p.isAI) continue; if(!G._aiTimers[pid]) G._aiTimers[pid] = 0; G._aiTimers[pid] += dt; const think = clamp(1.0 / p.difficulty, 0.2, 3.0); if(G._aiTimers[pid] < think) continue; G._aiTimers[pid] = 0;
    // build fleets if affordable and have shipyard
    const mySystems = G.systems.filter(s=>s.owner==pid);
    // try to build shipyard on good neutral system nearby
    if(Math.random() < 0.25){ // build shipyards sometimes
      for(let s of mySystems){ if(!s.buildings.shipyard && p.credits >= 120){ p.credits -= 120; s.queue.push({type:'shipyard', timeLeft:7, total:7, owner:pid}); break; } }
    }
    // build fleets on shipyards
    for(let s of mySystems){ if(s.buildings.shipyard && p.credits >= 100 && Math.random() < 0.6){ p.credits -= 100; s.queue.push({type:'fleet', timeLeft:5, total:5, owner:pid, strength: Math.max(1, Math.round(Math.random()*3 + p.difficulty))}); break; } }
    // send any idle fleets toward nearest non-owned target
    const idleFleets = G.fleets.filter(f=>f.owner==pid && !f.moving);
    for(let f of idleFleets){ const target = findNearestTarget(f.currentNode, pid); if(target){ const path = findPath(f.currentNode, target); if(path.length>1){ sendFleetAlong(f,path); break; } }
    }
  } }

function findNearestTarget(node, owner){ let best=null, bd=Infinity; for(let s of G.systems){ if(s.owner==owner) continue; const d = dist(node,s); if(d < bd){ bd=d; best=s; } } return best; }

// ========== UI & Interaction ==========
function setupUI(){ const canvas = document.getElementById('gameCanvas'); G.canvas = canvas; G.ctx = canvas.getContext('2d'); const minimap = document.getElementById('minimap'); G.minimapCtx = minimap.getContext('2d'); function resize(){ canvas.width = window.innerWidth - (document.getElementById('leftPane') ? document.getElementById('leftPane').offsetWidth + 40 : 40); canvas.height = window.innerHeight - 30; } window.addEventListener('resize', resize); resize();
  // menu
  const sysRange = document.getElementById('systemsRange'); const sysCount = document.getElementById('sysCount'); sysRange.addEventListener('input', ()=> sysCount.textContent = sysRange.value);
  const aiRange = document.getElementById('aiCount'); const aiLabel = document.getElementById('aiCountLabel'); aiRange.addEventListener('input', ()=> aiLabel.textContent = aiRange.value);
  document.getElementById('launchBtn').addEventListener('click', ()=>{ const diff = parseFloat(document.getElementById('difficulty').value); const systems = parseInt(document.getElementById('systemsRange').value,10); const seed = document.getElementById('seed').value.trim() || null; const aiCount = parseInt(document.getElementById('aiCount').value,10); startGame({systems:systems, difficulty:diff, aiCount:aiCount, seed:seed}); });
  document.getElementById('loadExample').addEventListener('click', ()=>{ document.getElementById('systemsRange').value=160; document.getElementById('sysCount').textContent=160; document.getElementById('difficulty').value=1.0; document.getElementById('aiCount').value=4; document.getElementById('aiCountLabel').textContent=4; document.getElementById('seed').value='example-42'; });
  document.getElementById('toMenu').addEventListener('click', ()=> stopGame());
  document.getElementById('buildMine').addEventListener('click', ()=> buildBuildingCommand('mine'));
  document.getElementById('buildShipyard').addEventListener('click', ()=> buildBuildingCommand('shipyard'));
  document.getElementById('buildFleet').addEventListener('click', ()=> buildFleetCommand());
  document.getElementById('sendFleet').addEventListener('click', ()=>{ if(G.selectedFleets.length>0){ G.sendMode = true; document.getElementById('sendFleet').textContent = 'Click destination'; } else alert('Select some fleets by dragging a box over them first.'); });
  document.getElementById('zoomSlider').addEventListener('input', (e)=>{ G.view.scale = parseFloat(e.target.value); draw(); });

  // canvas interaction: panning and clicking
  let isRightDown=false, lastX=0,lastY=0; let isLeftDown=false, selStart=null, selRect=null;
  canvas.addEventListener('mousedown', (ev)=>{ const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top; const pos = screenToWorld(sx,sy); if(ev.button===2){ isRightDown=true; lastX=ev.clientX; lastY=ev.clientY; }
    else if(ev.button===0){ isLeftDown=true; selStart = {sx,sy, wx:pos.x, wy:pos.y}; selRect = null; }
  });
  canvas.addEventListener('mousemove', (ev)=>{ const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top; const pos = screenToWorld(sx,sy);
    // panning
    if(isRightDown){ const dx=(lastX-ev.clientX)/G.view.scale; const dy=(lastY-ev.clientY)/G.view.scale; G.view.x += dx; G.view.y += dy; lastX=ev.clientX; lastY=ev.clientY; draw(); }
    // selection box
    if(isLeftDown && selStart){ selRect = {x0:selStart.sx, y0:selStart.sy, x1:sx, y1:sy}; draw(); }
    // hover detection for edges
    detectHover(sx,sy);
  });
  window.addEventListener('mouseup', (ev)=>{ if(ev.button===2) isRightDown=false; if(ev.button===0){ if(selRect){ // finalize selection
        finalizeSelectionRect(selRect); selRect=null; selStart=null; draw(); } isLeftDown=false; } });
  window.addEventListener('contextmenu', (e)=> e.preventDefault());
  canvas.addEventListener('wheel', (ev)=>{ ev.preventDefault(); const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top; const before = screenToWorld(sx,sy); const delta = -ev.deltaY * 0.0015; G.view.scale = clamp(G.view.scale * (1 + delta), 0.25, 2.5); document.getElementById('zoomSlider').value = G.view.scale; const after = screenToWorld(sx,sy); // maintain focus
    G.view.x += before.x - after.x; G.view.y += before.y - after.y; draw(); }, {passive:false});

  // single clicks: selecting systems or using sendMode
  canvas.addEventListener('click', (ev)=>{ if(G.sendMode){ const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top; const pos = screenToWorld(sx,sy); let nearest=null, nd=Infinity; for(let s of G.systems){ const d = Math.hypot(s.x-pos.x, s.y-pos.y); if(d<nd){ nd=d; nearest=s; }} if(nearest && nd < 18 / G.view.scale){ // send selected fleets
        for(let f of G.selectedFleets.slice()){ const path = findPath(f.currentNode, nearest); if(path.length>1){ sendFleetAlong(f, path); } }
        G.sendMode=false; document.getElementById('sendFleet').textContent='Send Fleet'; G.selectedFleets=[]; updateSelectionUI(); draw(); } else { alert('No valid destination selected. Click near a system.'); } return; }
    // otherwise, single-click selects a system
    const rect = canvas.getBoundingClientRect(); const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top; const pos = screenToWorld(sx,sy); // find nearest system
    let nearest=null, nd=Infinity; for(let s of G.systems){ const d = Math.hypot(s.x-pos.x, s.y-pos.y); if(d<nd){ nd=d; nearest=s; }} if(nearest && nd < 18 / G.view.scale){ // select system
      G.selectedSystem = nearest; G.selectedFleets=[]; updateSelectionUI(); draw(); } else { G.selectedSystem = null; updateSelectionUI(); draw(); }
  });

}

function screenToWorld(sx,sy){ const x = (sx)/G.view.scale + (G.view.x - G.canvas.width/2 / G.view.scale); const y = (sy)/G.view.scale + (G.view.y - G.canvas.height/2 / G.view.scale); return {x,y}; }
function worldToScreen(wx,wy){ const sx = ((wx - (G.view.x - G.canvas.width/2 / G.view.scale))) * G.view.scale; const sy = ((wy - (G.view.y - G.canvas.height/2 / G.view.scale))) * G.view.scale; return {x:sx,y:sy}; }

function detectHover(sx,sy){ // highlight nearest edge within threshold or node
  const pos = screenToWorld(sx,sy);
  G.hoverEdge = null; G.hoverNode = null;
  let best = Infinity; for(let e of G.edges){ const d = pointLineDist(pos.x,pos.y, e.a.x,e.a.y, e.b.x,e.b.y); if(d < best){ best=d; G.hoverEdge = e; } }
  if(best > 30 / G.view.scale) G.hoverEdge = null;
  // node hover
  for(let s of G.systems){ const d = Math.hypot(s.x-pos.x, s.y-pos.y); if(d < 12 / G.view.scale){ G.hoverNode = s; break; } }
}

function finalizeSelectionRect(rect){ // rectangle in screen coords -> select fleets inside
  const x0 = Math.min(rect.x0, rect.x1), x1 = Math.max(rect.x0, rect.x1), y0 = Math.min(rect.y0, rect.y1), y1 = Math.max(rect.y0, rect.y1);
  const p0 = screenToWorld(x0,y0), p1 = screenToWorld(x1,y1);
  const wx0 = Math.min(p0.x,p1.x), wx1 = Math.max(p0.x,p1.x), wy0 = Math.min(p0.y,p1.y), wy1 = Math.max(p0.y,p1.y);
  G.selectedFleets = [];
  for(let f of G.fleets){ if(!f.moving){ if(f.pos.x >= wx0 && f.pos.x <= wx1 && f.pos.y >= wy0 && f.pos.y <= wy1 && f.owner===1){ G.selectedFleets.push(f); } } }
  updateSelectionUI();
}

function updateSelectionUI(){ document.getElementById('credits').textContent = Math.floor(G.players[1].credits);
  document.getElementById('income').textContent = Math.floor(G.players[1].income);
  document.getElementById('timeLabel').textContent = Math.floor(G.time) + 's';
  const sel = G.selectedSystem; if(sel){ document.getElementById('selectedName').textContent = sel.name; document.getElementById('selectedOwner').textContent = 'Owner: ' + (sel.owner? (G.players[sel.owner] ? G.players[sel.owner].name : 'Unknown') : 'Neutral'); document.getElementById('selectedIncome').textContent = 'Prod: ' + sel.baseProd + ', Defense: ' + sel.defense + ', Buildings: ' + (sel.buildings.mine? 'Mine ':'') + (sel.buildings.shipyard? 'Yard':''); // queue
    const q = document.getElementById('buildQueue'); q.innerHTML = '';
    sel.queue.forEach((t,i)=>{ const el = document.createElement('div'); el.style.marginTop='6px'; el.innerHTML = `<div style="font-size:12px">${i+1}. ${t.type} <span style='float:right'>${t.timeLeft.toFixed(1)}s</span></div><div class='progressBar'><div class='progressFill' style='width:${Math.max(0,Math.min(100,((t.total - t.timeLeft)/t.total*100))) }%'></div></div>`; q.appendChild(el); });
  } else { document.getElementById('selectedName').textContent = 'None'; document.getElementById('selectedOwner').textContent = ''; document.getElementById('selectedIncome').textContent = ''; document.getElementById('buildQueue').innerHTML = ''; }
  document.getElementById('selFleetCount').textContent = G.selectedFleets.length;
}

// Build commands
function buildBuildingCommand(type){ const s = G.selectedSystem; if(!s){ alert('Select a system'); return; } if(s.owner !== 1){ alert('You must control the system to build here'); return; }
  const cost = (type==='mine'?80:120);
  if(G.players[1].credits < cost){ alert('Not enough credits'); return; }
  if(type==='mine' && s.buildings.mine){ alert('Mine already present'); return; }
  if(type==='shipyard' && s.buildings.shipyard){ alert('Shipyard already present'); return; }
  G.players[1].credits -= cost; s.queue.push({type:type, timeLeft:7, total:7, owner:1}); updateSelectionUI(); }

function buildFleetCommand(){ const s = G.selectedSystem; if(!s || s.owner !== 1){ alert('Select a system you control'); return; } if(!s.buildings.shipyard){ alert('You need a shipyard here to build fleets'); return; } const cost = 100; if(G.players[1].credits < cost){ alert('Not enough credits'); return; } G.players[1].credits -= cost; s.queue.push({type:'fleet', timeLeft:5, total:5, owner:1, strength:1}); updateSelectionUI(); }

// Pathfinding BFS
function findPath(a,b){ if(a===b) return [a]; const q=[a]; const prev=new Map(); prev.set(a,null); while(q.length){ const cur=q.shift(); for(let n of cur.connected){ if(prev.has(n)) continue; prev.set(n,cur); if(n===b){ // reconstruct
        const path=[n]; let p=cur; while(p){ path.unshift(p); p=prev.get(p); } return path; } q.push(n); } } return []; }

// Send fleet along path
function sendFleetAlong(f, path){ if(!path || path.length<2) return; f.path = path; f.pathIndex = 0; if(f.currentNode !== path[0]){ f.currentNode = path[0]; f.pos.x = path[0].x; f.pos.y = path[0].y; }
  // set first step
  f._from = path[0]; f._to = path[1]; f.moving = true; f.progress = 0; f.pathIndex = 1; }

// ========== Drawing ==========
function draw(){ const ctx = G.ctx, canvas = G.canvas; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#041226'; ctx.fillRect(0,0,canvas.width,canvas.height);
  // sectors
  for(let sec of G.sectors){ if(sec.hull && sec.hull.length>=3){ ctx.save(); ctx.beginPath(); for(let i=0;i<sec.hull.length;i++){ const p = sec.hull[i]; const s = worldToScreen(p.x,p.y); if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); } ctx.closePath(); ctx.fillStyle = sec.color; ctx.globalAlpha = 1.0; ctx.fill(); ctx.restore(); } }
  // edges
  for(let e of G.edges){ const sa = worldToScreen(e.a.x,e.a.y), sb = worldToScreen(e.b.x,e.b.y); ctx.beginPath(); ctx.lineWidth = Math.max(1, 1.5 * G.view.scale); const owner = laneOwner(e); ctx.strokeStyle = owner===0? 'rgba(160,170,190,0.14)' : owner===1? 'rgba(78,163,255,0.9)' : 'rgba(255,107,107,0.9)'; ctx.moveTo(sa.x,sa.y); ctx.lineTo(sb.x,sb.y); ctx.stroke(); }
  // highlight hovered edge
  if(G.hoverEdge){ const e=G.hoverEdge; const sa = worldToScreen(e.a.x,e.a.y), sb = worldToScreen(e.b.x,e.b.y); ctx.beginPath(); ctx.moveTo(sa.x,sa.y); ctx.lineTo(sb.x,sb.y); ctx.lineWidth = 4 * G.view.scale; ctx.strokeStyle = 'rgba(255,255,0,0.6)'; ctx.stroke(); }
  // systems
  for(let s of G.systems){ const sc = worldToScreen(s.x,s.y); ctx.beginPath(); const r = Math.max(3, 6*G.view.scale); const fill = s.owner===0? '#b0b8c6' : (s.owner===1? '#4ea3ff' : '#ff6b6b'); ctx.fillStyle = fill; ctx.arc(sc.x, sc.y, r, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=1; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.stroke(); // name
    ctx.font = `${10*G.view.scale}px sans-serif`; ctx.fillStyle='rgba(220,230,255,0.9)'; ctx.fillText(s.name, sc.x + 8*G.view.scale, sc.y - 6*G.view.scale);
    // buildings markers
    if(s.buildings.mine){ drawHex(ctx, sc.x - 8*G.view.scale, sc.y + 10*G.view.scale, 6*G.view.scale, '#d0b84a'); }
    if(s.buildings.shipyard){ drawSquare(ctx, sc.x + 8*G.view.scale, sc.y + 10*G.view.scale, 8*G.view.scale, '#9ad4ff'); }
  }
  // sector labels
  for(let sec of G.sectors){ if(sec.systems.length){ const avgX = sec.systems.reduce((a,b)=>a+b.x,0)/sec.systems.length; const avgY = sec.systems.reduce((a,b)=>a+b.y,0)/sec.systems.length; const p = worldToScreen(avgX,avgY); ctx.font = `${12*G.view.scale}px sans-serif`; ctx.fillStyle='rgba(200,220,255,0.6)'; ctx.fillText(sec.name, p.x-20, p.y-8); } }
  // fleets
  for(let f of G.fleets){ const p = worldToScreen(f.pos.x,f.pos.y); drawTriangle(ctx, p.x, p.y, f); ctx.fillStyle='white'; ctx.font = `${11*G.view.scale}px sans-serif`; ctx.fillText(f.strength, p.x+8, p.y-6); }
  // selection highlight
  if(G.selectedSystem){ const s = G.selectedSystem; const sc = worldToScreen(s.x,s.y); ctx.beginPath(); ctx.arc(sc.x, sc.y, 12*G.view.scale,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth = 2; ctx.stroke(); }
  if(G.selectedFleets.length>0){ for(let f of G.selectedFleets){ const p = worldToScreen(f.pos.x,f.pos.y); ctx.beginPath(); ctx.arc(p.x,p.y,12*G.view.scale,0,Math.PI*2); ctx.strokeStyle='yellow'; ctx.lineWidth=2; ctx.stroke(); } }
  // draw selection rect if exists
  // note: selection rect is drawn inside event loop; store temporary in G._selRect
  if(G._selRect){ const r = G._selRect; ctx.save(); ctx.strokeStyle='rgba(200,200,255,0.9)'; ctx.setLineDash([6,6]); ctx.strokeRect(r.x, r.y, r.w, r.h); ctx.restore(); }
  // minimap
  drawMinimap();
}

function drawTriangle(ctx,x,y,f){ ctx.save(); ctx.translate(x,y); let angle = 0; if(f.moving && f._from && f._to){ angle = Math.atan2(f._to.y - f._from.y, f._to.x - f._from.x); } ctx.rotate(angle); ctx.beginPath(); const s = 6 * Math.max(1, G.view.scale); ctx.moveTo(s,0); ctx.lineTo(-s*0.7, s*0.7); ctx.lineTo(-s*0.7, -s*0.7); ctx.closePath(); ctx.fillStyle = f.owner===1? '#4ea3ff' : '#ff6b6b'; ctx.fill(); ctx.restore(); }
function drawHex(ctx,x,y,r,color){ ctx.save(); ctx.translate(x,y); ctx.beginPath(); for(let i=0;i<6;i++){ const a = Math.PI/3 * i; const px = Math.cos(a)*r, py = Math.sin(a)*r; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); } ctx.closePath(); ctx.fillStyle=color; ctx.fill(); ctx.restore(); }
function drawSquare(ctx,x,y,s,color){ ctx.save(); ctx.beginPath(); ctx.rect(x - s/2, y - s/2, s, s); ctx.fillStyle=color; ctx.fill(); ctx.restore(); }

function laneOwner(edge){ if(edge.a.owner===edge.b.owner) return edge.a.owner; if(edge.a.owner===1 || edge.b.owner===1) return 1; for(let pid in G.players){ if(pid>1 && (edge.a.owner==pid || edge.b.owner==pid)) return parseInt(pid); } return 0; }

function drawMinimap(){ const ctx = G.minimapCtx; const w=200, h=120; ctx.clearRect(0,0,w,h); ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(0,0,w,h); const fx = w / G.width, fy = h / G.height; // edges
  ctx.lineWidth=1; for(let e of G.edges){ ctx.beginPath(); ctx.moveTo(e.a.x*fx, e.a.y*fy); ctx.lineTo(e.b.x*fx, e.b.y*fy); ctx.strokeStyle='rgba(200,200,220,0.12)'; ctx.stroke(); }
  for(let s of G.systems){ ctx.fillStyle = s.owner===1? '#4ea3ff' : s.owner>1? '#ff6b6b' : '#b0b8c6'; ctx.fillRect(s.x*fx - 1, s.y*fy -1, 2,2); }
  // viewport rect
  const vx = (G.view.x - (G.canvas.width/2 / G.view.scale)) * fx; const vy = (G.view.y - (G.canvas.height/2 / G.view.scale)) * fy; const vw = (G.canvas.width / G.view.scale) * fx; const vh = (G.canvas.height / G.view.scale) * fy; ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.strokeRect(vx,vy,vw,vh);
}

// ========== Win Conditions ==========
function checkWinConditions(){ // if no other AI systems and no ai fleets -> win
  const otherSystems = G.systems.filter(s=>s.owner && s.owner !== 1).length; const otherFleets = G.fleets.filter(f=>f.owner !== 1).length; const playerSystems = G.systems.filter(s=>s.owner===1).length; const playerFleets = G.fleets.filter(f=>f.owner===1).length;
  if(otherSystems===0 && otherFleets===0){ setTimeout(()=>{ alert('You Win!'); stopGame(); }, 10); }
  if(playerSystems===0 && playerFleets===0){ setTimeout(()=>{ alert('AI Wins!'); stopGame(); }, 10); }
}

// ========== Start / Stop ==========
let rafId=null, lastTime=performance.now();
function startGame(settings){ G.settings = settings; generateGalaxy(settings);
  // initialize UI
  document.getElementById('menu').style.display='none'; document.getElementById('topBar').style.display='flex'; document.getElementById('hud').style.display='block'; document.getElementById('footer').style.display='block'; document.getElementById('statusText').textContent = 'Running — Seed: ' + (G.seed||'random');
  // give each AI some credits and set difficulty
  for(let pid in G.players){ if(G.players[pid].isAI){ G.players[pid].credits = 300 * settings.difficulty; G.players[pid].difficulty = settings.difficulty; } }
  // starting fleets for player and ais
  const pStart = G.systems.find(s=>s.owner===1); if(pStart) G.fleets.push(new Fleet(G.nextFleetId++,1,3,pStart));
  for(let pid in G.players){ if(G.players[pid].isAI){ const s = G.systems.find(x=>x.owner==pid); if(s) G.fleets.push(new Fleet(G.nextFleetId++, parseInt(pid), Math.max(1,2 + Math.floor(Math.random()*3)), s)); } }
  // start loop
  G.running = true; lastTime = performance.now(); function loop(t){ const dt = Math.min(0.1, (t - lastTime)/1000); lastTime = t; tick(dt); rafId = requestAnimationFrame(loop); }
  rafId = requestAnimationFrame(loop);
}

function stopGame(){ G.running = false; cancelAnimationFrame(rafId); document.getElementById('menu').style.display='block'; document.getElementById('topBar').style.display='none'; document.getElementById('hud').style.display='none'; document.getElementById('footer').style.display='none'; }

// ========== Init ==========
setupUI(); // initial preview
G.settings.systems = 120; G.settings.aiCount = 3; G.settings.difficulty = 1.0; generateGalaxy(G.settings); draw();

</script>
</body>
</html>
